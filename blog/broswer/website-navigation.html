<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从浏览器输入网址到页面加载，中间发生了什么？ | crise&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./assets/logo.png">
    <meta name="description" content="一名程序员/前端人的技术博客">
    
    <link rel="preload" href="/assets/css/0.styles.1cd9ab6a.css" as="style"><link rel="preload" href="/assets/js/app.237e33b5.js" as="script"><link rel="preload" href="/assets/js/2.a6e094ff.js" as="script"><link rel="preload" href="/assets/js/14.6926c1c5.js" as="script"><link rel="prefetch" href="/assets/js/10.ed6b7b4f.js"><link rel="prefetch" href="/assets/js/11.33a35b98.js"><link rel="prefetch" href="/assets/js/12.545dcf20.js"><link rel="prefetch" href="/assets/js/13.0157a43a.js"><link rel="prefetch" href="/assets/js/15.de7aef62.js"><link rel="prefetch" href="/assets/js/16.0b9d8c28.js"><link rel="prefetch" href="/assets/js/17.45f356c9.js"><link rel="prefetch" href="/assets/js/18.5e50c60e.js"><link rel="prefetch" href="/assets/js/19.d739307b.js"><link rel="prefetch" href="/assets/js/20.7d3dc31c.js"><link rel="prefetch" href="/assets/js/21.5f1ef20a.js"><link rel="prefetch" href="/assets/js/22.5864a5a2.js"><link rel="prefetch" href="/assets/js/23.ec78678c.js"><link rel="prefetch" href="/assets/js/24.316a50ac.js"><link rel="prefetch" href="/assets/js/25.e7923a60.js"><link rel="prefetch" href="/assets/js/26.fd02b552.js"><link rel="prefetch" href="/assets/js/27.0003fc19.js"><link rel="prefetch" href="/assets/js/28.fccb544e.js"><link rel="prefetch" href="/assets/js/29.21f2e63a.js"><link rel="prefetch" href="/assets/js/3.f3817cd8.js"><link rel="prefetch" href="/assets/js/30.f706c3a5.js"><link rel="prefetch" href="/assets/js/31.93eb136e.js"><link rel="prefetch" href="/assets/js/32.f1918a14.js"><link rel="prefetch" href="/assets/js/33.633fdfb4.js"><link rel="prefetch" href="/assets/js/34.1f46d635.js"><link rel="prefetch" href="/assets/js/35.a090b183.js"><link rel="prefetch" href="/assets/js/36.ea5de301.js"><link rel="prefetch" href="/assets/js/37.01ed1858.js"><link rel="prefetch" href="/assets/js/38.6c04b42d.js"><link rel="prefetch" href="/assets/js/39.61a2c924.js"><link rel="prefetch" href="/assets/js/4.9b118658.js"><link rel="prefetch" href="/assets/js/40.cd078337.js"><link rel="prefetch" href="/assets/js/41.9d443262.js"><link rel="prefetch" href="/assets/js/42.4b91203f.js"><link rel="prefetch" href="/assets/js/43.415a3857.js"><link rel="prefetch" href="/assets/js/44.b4aaf64d.js"><link rel="prefetch" href="/assets/js/45.0175e1e7.js"><link rel="prefetch" href="/assets/js/46.76ddb299.js"><link rel="prefetch" href="/assets/js/47.24fc1119.js"><link rel="prefetch" href="/assets/js/48.d753a44d.js"><link rel="prefetch" href="/assets/js/49.d4b652dc.js"><link rel="prefetch" href="/assets/js/5.317978c4.js"><link rel="prefetch" href="/assets/js/50.6c2887ad.js"><link rel="prefetch" href="/assets/js/51.3d0febed.js"><link rel="prefetch" href="/assets/js/52.6996c471.js"><link rel="prefetch" href="/assets/js/53.d7277718.js"><link rel="prefetch" href="/assets/js/54.d89f5330.js"><link rel="prefetch" href="/assets/js/55.b3197515.js"><link rel="prefetch" href="/assets/js/56.98cd9448.js"><link rel="prefetch" href="/assets/js/57.ad53dd47.js"><link rel="prefetch" href="/assets/js/58.8c1618f3.js"><link rel="prefetch" href="/assets/js/59.94460e81.js"><link rel="prefetch" href="/assets/js/6.a0219e38.js"><link rel="prefetch" href="/assets/js/60.3b7da87f.js"><link rel="prefetch" href="/assets/js/61.e608e32a.js"><link rel="prefetch" href="/assets/js/62.1e131ad7.js"><link rel="prefetch" href="/assets/js/63.41ea7b98.js"><link rel="prefetch" href="/assets/js/64.4f7fd140.js"><link rel="prefetch" href="/assets/js/65.1c0798b5.js"><link rel="prefetch" href="/assets/js/66.7d7588f6.js"><link rel="prefetch" href="/assets/js/67.739991ea.js"><link rel="prefetch" href="/assets/js/68.f9b883d5.js"><link rel="prefetch" href="/assets/js/69.9edfe956.js"><link rel="prefetch" href="/assets/js/7.99a9934c.js"><link rel="prefetch" href="/assets/js/70.db60f31a.js"><link rel="prefetch" href="/assets/js/71.00b04458.js"><link rel="prefetch" href="/assets/js/72.5ee17ade.js"><link rel="prefetch" href="/assets/js/73.24fde59b.js"><link rel="prefetch" href="/assets/js/74.7d870932.js"><link rel="prefetch" href="/assets/js/75.75f6627d.js"><link rel="prefetch" href="/assets/js/76.ce1ead80.js"><link rel="prefetch" href="/assets/js/77.208f1a5c.js"><link rel="prefetch" href="/assets/js/8.9f6f4f79.js"><link rel="prefetch" href="/assets/js/9.abcfea03.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1cd9ab6a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">crise's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="https://baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="https://baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浏览器</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/broswer/broswer-framework.html" class="sidebar-link">一文搞定浏览器架构</a></li><li><a href="/blog/broswer/kernel.html" class="sidebar-link">一文看懂浏览器内核</a></li><li><a href="/blog/broswer/useragent.html" class="sidebar-link">浏览器和UserAgent发展史</a></li><li><a href="/blog/broswer/compatibility.html" class="sidebar-link">浏览器兼容性问题研究</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>http</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/broswer/http.html" class="sidebar-link">一文读懂http</a></li><li><a href="/blog/broswer/http-cache.html" class="sidebar-link">浏览器缓存机制</a></li><li><a href="/blog/broswer/https.html" class="sidebar-link">深入理解HTTPS</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>原理篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/broswer/website-navigation.html" aria-current="page" class="active sidebar-link">从浏览器输入网址到页面加载，中间发生了什么？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#总体流程" class="sidebar-link">总体流程</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_1-url解析" class="sidebar-link">1. URL解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_1-1-解析输入" class="sidebar-link">1.1 解析输入</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_1-2-处理url并发送http请求" class="sidebar-link">1.2 处理URL并发送HTTP请求</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_1-3-延伸阅读" class="sidebar-link">1.3 延伸阅读</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_2-dns寻址" class="sidebar-link">2. DNS寻址</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_2-1-什么是域名解析" class="sidebar-link">2.1 什么是域名解析</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_2-2-dns寻址流程" class="sidebar-link">2.2 DNS寻址流程</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_2-3-优化方案" class="sidebar-link">2.3 优化方案</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_2-4-延伸阅读" class="sidebar-link">2.4 延伸阅读</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_3-建立tcp连接" class="sidebar-link">3 建立TCP连接</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_3-1-tcp-三次握手" class="sidebar-link">3.1 TCP 三次握手</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_3-2-优化方案" class="sidebar-link">3.2 优化方案</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_3-3-延伸阅读" class="sidebar-link">3.3 延伸阅读</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_4-发送http请求" class="sidebar-link">4 发送HTTP请求</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_4-1-客户端主机封装http请求报文" class="sidebar-link">4.1 客户端主机封装http请求报文</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_4-2-优化方案" class="sidebar-link">4.2 优化方案</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_4-3-延伸阅读" class="sidebar-link">4.3 延伸阅读</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_5-服务器处理请求并返回-http-响应报文" class="sidebar-link">5 服务器处理请求并返回 HTTP 响应报文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_5-1-服务器主机传递http请求报文" class="sidebar-link">5.1 服务器主机传递http请求报文</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_5-2-服务器处理请求并返回http响应报文" class="sidebar-link">5.2 服务器处理请求并返回http响应报文</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_5-3-优化方案" class="sidebar-link">5.3 优化方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_6-浏览器接收响应并解析渲染页面" class="sidebar-link">6 浏览器接收响应并解析渲染页面</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_6-1-接收响应" class="sidebar-link">6.1 接收响应</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_6-2-解析渲染页面" class="sidebar-link">6.2 解析渲染页面</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#_6-3-优化方案" class="sidebar-link">6.3 优化方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/website-navigation.html#参考文档" class="sidebar-link">参考文档</a></li></ul></li><li><a href="/blog/broswer/render-mechanism.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/blog/broswer/js-mechanism.html" class="sidebar-link">JS执行机制</a></li><li><a href="/blog/broswer/reflow-repaint-composite.html" class="sidebar-link">一文看懂浏览器重排、重绘与合成</a></li><li><a href="/blog/broswer/compositor-layer-manage.html" class="sidebar-link">合成层优化</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>web跨端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架及原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运维相关</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="从浏览器输入网址到页面加载-中间发生了什么"><a href="#从浏览器输入网址到页面加载-中间发生了什么" class="header-anchor">#</a> 从浏览器输入网址到页面加载，中间发生了什么？</h1> <p>作为前端，这个问题经常作为面试题出现用来考察你的知识体系。最近在做浏览器方面的专题，看了<a href="https://book.douban.com/subject/25910556/" target="_blank" rel="noopener noreferrer">WebKit技术内幕<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和网上的一些文章，结合自己的理解，来详细阐述下具体的步骤。</p> <h2 id="总体流程"><a href="#总体流程" class="header-anchor">#</a> 总体流程</h2> <p><img src="/assets/img/navigation.2d1a795e.png" alt="流程图">
从用户输入url，到网页加载成功，大体来说可以分为以下几个步骤：</p> <ol><li>URL 解析</li> <li>DNS 寻址：将域名解析成 IP 地址</li> <li>建立 TCP 连接：TCP 三次握手</li> <li>发送 HTTP 请求</li> <li>服务器处理请求并返回 HTTP 报文</li> <li>浏览器接收响应并解析渲染页面</li> <li>断开连接：TCP 四次挥手</li></ol> <h2 id="_1-url解析"><a href="#_1-url解析" class="header-anchor">#</a> 1. URL解析</h2> <h3 id="_1-1-解析输入"><a href="#_1-1-解析输入" class="header-anchor">#</a> 1.1 解析输入</h3> <p>用户在浏览器地址栏输入内容，浏览器主进程的UI线程会解析你的输入，看看输入的内容是否符合 <code>URL规则</code>：</p> <ul><li>不符合，则拼接成默认搜索引擎加关键字的 URL 进行搜索；</li> <li>符合，则会解析URL提取出协议、域名、端口号，对于一些特殊字符，在传递的时候还需要进行编码解码。</li></ul> <h3 id="_1-2-处理url并发送http请求"><a href="#_1-2-处理url并发送http请求" class="header-anchor">#</a> 1.2 处理URL并发送HTTP请求</h3> <p>敲击回车，给网址加上协议头，浏览器主进程便将该URL转发给网络线程（在内存资源足够时，浏览器进程会将网络线程拆分成独立的网络进程，甚至UI线程也会单独拆分）。</p> <p>UI线程将请求地址传递给网线线程时，UI线程就已经知道了要访问的站点。此时UI线程就可以开始查找或启动一个渲染进程，这个动作与让网络线程下载数据是同时的。如果网络线程按照预期获取到数据，则渲染进程就已经可以开始渲染了，这个动作减少了从网络线程开始请求数据到渲染进程可以开始渲染页面的时间。</p> <p>随后网络线程会依次查找 <code>Memory Cache</code>、<code>Disk Cache</code> 中是否有缓存内容，有且没过期则使用，否则则发送http请求。</p> <h3 id="_1-3-延伸阅读"><a href="#_1-3-延伸阅读" class="header-anchor">#</a> 1.3 延伸阅读</h3> <p><a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener noreferrer">你所不知道的 HSTS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：HSTS（HTTP Strict Transport Security），简单说就是强制客户端使用 HTTPS 访问页面，这个过程有效避免了中间人对 80 端口的劫持，同时也为浏览器节省来一次 302/301 的跳转请求。</p> <p><a href="/blog/broswer/broswer-framework.html#浏览器多进程架构">浏览器多进程架构</a>：webkit2、blink内核浏览器都采用了多进程架构模式，这有助于增强浏览器的稳定性和安全性。</p> <h2 id="_2-dns寻址"><a href="#_2-dns寻址" class="header-anchor">#</a> 2. DNS寻址</h2> <div class="custom-block tip"><p class="custom-block-title">名称解释</p> <p><strong>IP地址（IP Address）</strong>：指互联网协议地址。是<code>IP协议</code>提供的一种统一的地址格式，IP协议为每一个连接互联网的设备（不管是交换机、PC还是其他设备）分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址分为<code>IPv4</code>和<code>IPv6</code>两种，<code>IPv4</code>使用4字节共32位（如192.168.1.1）地址，我们记起来可能会好点，而<code>IPv6</code>地址共16字节128位（如2408:8207:250d:76c0:c872:b2d4:3900:d000），纯靠人力几乎就不可能记忆了，所以这也就限制了直接使用ip地址进行访问，于是域名以及DNS服务便应运而生。</p> <p><strong>域名（Domain）</strong>：如果说IP地址相当于你的身份证，那么域名就相当于你独一无二的网名。如：<code>baidu.com</code>，它的作用就是便于记忆，那为什么机器在处理IP数据报时要使用IP地址而不使用域名呢？这是因为IP地址的长度是固定的32位（IPv4固定32位），而域名长度不是固定的，机器处理起来比较困难。</p></div> <p>浏览器请求网址页面，首先得经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP地址。</p> <h3 id="_2-1-什么是域名解析"><a href="#_2-1-什么是域名解析" class="header-anchor">#</a> 2.1 什么是域名解析</h3> <p><a href="https://baike.baidu.com/item/dns%E5%8D%8F%E8%AE%AE/1860066" target="_blank" rel="noopener noreferrer">DNS协议<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。<code>DNS服务器</code> 是一台专门处理DNS协议的网络服务器，我们的域名解析简单来说就是在 <code>DNS服务器</code> 上查找或者添加一条信息记录。</p> <div class="language- extra-class"><pre class="language-text"><code>baidu.com  39.156.66.10（服务器外网IP地址）80（服务器端口号）
</code></pre></div><h3 id="_2-2-dns寻址流程"><a href="#_2-2-dns寻址流程" class="header-anchor">#</a> 2.2 DNS寻址流程</h3> <ol><li>浏览器缓存中找：浏览器会按照一定的频率缓存 DNS 记录；</li> <li>操作系统缓存中找：操作系统也有自己的 DNS缓存，如果浏览器缓存中找不到需要的 DNS记录，则会在操作系统存在本地的Hosts文件里找，没有的话则向 DNS 服务器发送查询请求；</li> <li>路由缓存中找：路由器也有 DNS 缓存；</li> <li>从ISP（Internet Service Provider：互联网服务提供商）的 DNS服务器中找：ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。如果在路由器中找不到DNS缓存的话，就去ISP的DNS服务器中找；</li> <li><a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener noreferrer">根域名服务器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>查询：在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，进行<code>递归查询</code>：</li></ol> <ul><li>根域名服务器查找www.baidu.com所对应的ip，有，则返回ip到本地域名服务商；</li> <li>根域名服务器未找到相应ip，则会返回一级域名（.com）服务器地址给本地域名服务商；</li> <li>在一级域名服务器查询www.baidu.com，有，则返回；</li> <li>一级域名服务器未找到相应ip，则返回二级域名(.baidu.com)服务器地址给本地域名服务商；</li> <li>在二级域名服务器中查询www.baidu.com</li> <li>二级域名服务器查看本地name.conf，是否有www主机的记录</li> <li>查到www主机的记录，返回www主机的ip到二级域名服务器</li> <li>二级域名服务器返回ip到本地域名服务器</li> <li>本地域名服务器返回ip到浏览器</li></ul> <h3 id="_2-3-优化方案"><a href="#_2-3-优化方案" class="header-anchor">#</a> 2.3 优化方案</h3> <p>一般来说，一次DNS解析需要耗费 20-120ms，所以为了优化DNS，我们可以考虑两个方向：</p> <ul><li>减少DNS请求次数 - 减少Host主机数</li> <li>缩短DNS解析时间 - dns-prefetch</li></ul> <h4 id="减少主机数"><a href="#减少主机数" class="header-anchor">#</a> 减少主机数</h4> <p>主机数很多的情况下，虽然可以最大化增加页面并行http请求数量，但是由于DNS解析（特别是第一次访问，没有浏览器缓存和系统缓存的情况下）时长增加，用户网络带宽受限，用户设备CPU占用率变高（并行下载数量越大，CPU占用率越高），也会导致响应时长变慢。</p> <p>这时候减少主机数，可以减少DNS请求次数，但是却会减少网站的并行http请求数量，也会导致响应时间变慢。</p> <p>雅虎军规建议，单个页面主机数建议设置为2-4个。</p> <h4 id="dns-prefetch-和-preconnect"><a href="#dns-prefetch-和-preconnect" class="header-anchor">#</a> dns-prefetch 和 preconnect</h4> <p><code>dns-prefetch</code>（DNS预获取）是前端网络性能优化的一种措施。它根据浏览器定义的规则，提前解析之后可能会用到的域名（可能是后面要加载的文件，也可能是用户尝试打开的链接目标），使解析结果缓存到<code>系统缓存</code>中，缩短DNS解析时间，进而提高网站的访问速度。</p> <p>如果某一时间内，有多个请求都发送给同一个服务器，那么DNS解析会多次并且重复触发。这样会导致整体的网页加载有延迟的情况。虽然DNS解析占用不了多大带宽，但是它会产生很高的延迟，尤其是对于移动网络会更为明显。</p> <p>因此，为了减少DNS解析产生的延迟，我们可以通过dns-prefetch预解析技术有效地缩短DNS解析时间。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://sta.xxx.com/<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> 
</code></pre></div><p>如果站点是通过HTTPS服务的，<code>dns-prefetch</code> 与 <code>preconnect(预连接)</code> 的组合会涵盖DNS解析，建立TCP连接以及执行TLS握手。将两者结合起来可提供进一步减少跨域请求的感知延迟的机会。如下所示：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preconnect<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://sta.xxx.com/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://sta.xxx.com/<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>ps：如果页面需要建立与许多第三方域的连接，则将它们预先连接会适得其反。 <code>preconnect</code> 提示最好仅用于最关键的连接（比如js和css资源的cdn域名连接）。对于其他的，只需使用 <link rel="dns-prefetch"> 即可节省第一步的时间DNS查找。</p> <h3 id="_2-4-延伸阅读"><a href="#_2-4-延伸阅读" class="header-anchor">#</a> 2.4 延伸阅读</h3> <ul><li><p><a href="https://zhuanlan.zhihu.com/p/377974683" target="_blank" rel="noopener noreferrer">什么是 DNS 劫持<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：DNS劫持也被称为域名劫持或者是DNS重定向，最直接的后果就是将用户重定向到恶意站点或者是让我们的网页直接打不开。</p></li> <li><p><a href="https://juejin.cn/post/7031815988031160328" target="_blank" rel="noopener noreferrer">前端 dns-prefetch 优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：配置<code>dns-prefetch</code>，可以使下一次DNS解析时长低至0-1ms。</p></li></ul> <h2 id="_3-建立tcp连接"><a href="#_3-建立tcp连接" class="header-anchor">#</a> 3 建立TCP连接</h2> <p>tcp连接建立是在传输层做的事，在建立连接前，会先进行 TCP 三次握手。</p> <h3 id="_3-1-tcp-三次握手"><a href="#_3-1-tcp-三次握手" class="header-anchor">#</a> 3.1 TCP 三次握手</h3> <p><img src="/assets/img/tcp-third.55873bce.png" alt="三次握手时序图"> 
最开始的时候两端的TCP进程都是处于CLOSED（关闭）状态。主动打开连接的为客户端，被动打开连接的是服务器。</p> <h4 id="tcp三次握手时序"><a href="#tcp三次握手时序" class="header-anchor">#</a> tcp三次握手时序</h4> <ul><li><ol><li>TCP服务器进程先创建 <strong>传输控制块TCB</strong>（TCB中存储了每个连接中的一些重要消息，如：TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号等），时刻准备接受客户进程的连接请求，此时服务器进程就进入了LISTEN（监听）状态；</li></ol></li> <li><ol start="2"><li>第一次握手：TCP客户进程也是先创建 <strong>传输控制块TCB</strong>，然后向服务器发出连接请求报文段，这时报文首部中的同部位<code>SYN = 1</code>，同时随机的选择一个初始序列号 <code>seq = x</code>（随机化选择可以避免某些安全性攻击），并将此序列号放在该<code>起始SYN报文段</code>的序号字段中，此时，TCP客户端进程进入了 <code>SYN-SENT</code>（同步已发送状态）状态。<red>TCP协议规定，SYN 报文段（SYN = 1的报文段）不能携带数据，但需要消耗掉一个序号</red>。</li></ol></li> <li><ol start="3"><li>第二次握手：服务器收到请求报文后，传输层会从IP数据报中提取出<code>SYN报文段</code>，如果同意连接，则为该TCP链接分配TCP缓存和变量，并发出确认报文。在确认报文段中应把 ACK位和SYN位都置为1，确认号<code>ack = x+1</code>，同时也要为自己初始化一个序列号 <code>seq = y</code>，此时，TCP服务器进程进入了 <code>SYN-RCVD</code>（同步收到）状态。<red>这个TCP报文段也不能携带数据，但是同样要消耗一个序号</red>。</li></ol></li> <li><ol start="4"><li>第三次握手：TCP客户进程收到确认后，也要给该连接分配TCP缓存和变量，还要向服务器给出确认。确认报文段的<code>ACK=1</code>，确认号<code>ack = y+1</code>，自己的序列号<code>seq = x+1</code>，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。<red>TCP规定，ACK报文段可以携带数据（HTTP请求报文），但是如果不携带数据则不消耗序号</red>。</li></ol></li> <li><ol start="5"><li>当服务器收到客户端的确认后也进入<red>ESTABLISHED状态</red>，此后双方就可以开始通信了。</li></ol></li></ul> <h4 id="为什么客户端还要发送一次确认"><a href="#为什么客户端还要发送一次确认" class="header-anchor">#</a> 为什么客户端还要发送一次确认？</h4> <p>这主要是为了防止<code>已失效的连接请求报文段</code>突然又传给了服务端，因而产生错误。</p> <p>正常情况下客户端发出连接请求后，如果因为连接请求报文丢失而未收到确认，于是客户端会重新发送连接请求。后来客户端收到确认后，就建立了连接。数据传输完毕后，就释放了连接。这种情况下客户端发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务端。没有“已失效的连接请求报文段”。</p> <p>但如果出现了一种异常情况，即客户端发出的第一个链接请求报文段没有丢失，而是因为各种原因在某些网络节点长时间滞留，以致延误到连接释放后的某个时间点才到达服务端。这本应该是一个“已失效的连接请求报文段”，但服务端收到后，误以为是客户端又发起了一次新的连接请求，于是向客户端发出确认报文段，同意建立连接。</p> <p><red>假如没有第三次握手，那么只要服务端发出确认，新的连接便已经建立，便一直等待客户端发来的数据（当然由于保活机制，也不会无限等待下去）。但是此时客户端没有发出新的建立连接的请求，也不会向服务端发送数据，这时候许多服务器资源便被浪费了。</red></p> <h4 id="如果已经建立了连接-但是客户端突然出了问题怎么办"><a href="#如果已经建立了连接-但是客户端突然出了问题怎么办" class="header-anchor">#</a> 如果已经建立了连接，但是客户端突然出了问题怎么办？</h4> <p>TCP协议设有一个<code>保活计时器（keepalive timer）</code>，如果客户端出了问题，服务器不会一直等下去，浪费资源。服务器每收到一次客户端的请求后都会重新复位保活计时器，时间通常设置为两小时，如果两小时过后还没有收到客户端发来的数据，服务器就会发送一个<code>探测报文段</code>，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p> <h3 id="_3-2-优化方案"><a href="#_3-2-优化方案" class="header-anchor">#</a> 3.2 优化方案</h3> <p>每一个http请求都会打开一个tcp socket连接（三次握手），当交互完毕后会关闭这个连接（四次挥手）。客户端和服务器端每次建立和关闭连接都是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。</p> <h4 id="http连接复用"><a href="#http连接复用" class="header-anchor">#</a> http连接复用</h4> <p>如果我们当前网页中，可能引入了几十个js、css文件，上百张图片，如果每请求一个资源，就创建一个连接，然后关闭，代价实在太大了。</p> <p>那么我们可以在HTTP/1.0请求头中加上<code>Connection: keep-alive</code>，但是得服务端配置支持长连接，或者升级到HTTP/1.1（默认开启keep-alive）。以便在加载同一个网页中的内容时，尽量的复用连接。（如果 HTTP 服务存在长轮询或较长间隔请求，而且超过 <code>Keep-Alive</code> 的设置（比如 Keep-Alive 5 秒，但轮询周期是 6 秒），则可能会造成大量的无用途连接，白白占用系统资源。）</p> <p><red>但是keep-alive长连接中，请求是串行发送的，而且由于HTTP/1.x是纯文本协议，在资源块（resource chunks）之间不使用分隔符（响应只能按序接收），这就可能存在<a href="https://zhuanlan.zhihu.com/p/330300133" target="_blank" rel="noopener noreferrer">队头阻塞（Head-of-Line blocking）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>问题</red>（比如第一个请求文件特别大，阻塞了后面文件请求的响应）。</p> <h4 id="http-2多路复用"><a href="#http-2多路复用" class="header-anchor">#</a> HTTP/2多路复用</h4> <p>启用<code>HTTP/2</code>协议（传输性能得到提升）。HTTP/2（每块资源都是二进制流，在每个资源块前添加了数据帧，有id可以标识响应的数据属于哪个请求）不仅能够实现TCP复用，并且解决了队头阻塞问题（可以并行交错的请求和响应，哪个请求响应的快，就先接收哪个响应体）。</p> <h3 id="_3-3-延伸阅读"><a href="#_3-3-延伸阅读" class="header-anchor">#</a> 3.3 延伸阅读</h3> <p><a href="https://baike.baidu.com/item/SYN%E6%94%BB%E5%87%BB/14762413" target="_blank" rel="noopener noreferrer">SYN洪泛攻击<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：攻击者发送大量的TCP SYN报文段，而不完成第三步握手的步骤。而服务器不断为这种半开连接分配资源，等待确认，导致服务器连接资源耗尽。（由于第二次握手服务端会分配TCP缓存和变量，使得TCP易于收到SYN洪泛的拒绝服务攻击）。</p> <p><a href="https://zhuanlan.zhihu.com/p/330300133" target="_blank" rel="noopener noreferrer">队头阻塞（Head-of-Line blocking）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：带你了解什么叫队头阻塞，以及http/1.x、http/2、http/3上队头阻塞的区别。</p> <p><a href="https://github.com/ljianshu/Blog/issues/50" target="_blank" rel="noopener noreferrer">深入理解HTTPS工作原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：HTTPS协议的本质就是<code>HTTP + SSL(or TLS)</code>。在HTTP报文传递给传输层之前，先用SSL对HTTP报文进行加密。从层级结构来看它位于HTTP协议与传输层之间。HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。</p> <h2 id="_4-发送http请求"><a href="#_4-发送http请求" class="header-anchor">#</a> 4 发送HTTP请求</h2> <p>HTTP请求报文结构：</p> <div class="language-md extra-class"><pre class="language-md"><code>  <span class="token list punctuation">-</span> 请求行（Request Line）：请求方法、请求资源URL、HTTP协议版本号（如：GET /index.html HTTP/1.1）
  <span class="token list punctuation">-</span> 首部行（Request Header）：用来说明浏览器、服务器或报文主体的一些信息。由 参数/值 对组成
  <span class="token list punctuation">-</span> 请求实体：请求报文中传给服务端的具体参数
</code></pre></div><h3 id="_4-1-客户端主机封装http请求报文"><a href="#_4-1-客户端主机封装http请求报文" class="header-anchor">#</a> 4.1 客户端主机封装http请求报文</h3> <blockquote><p>ps：如果uri资源被强缓存，则会直接从本地读取，不会发送http请求。
客户端请求从应用层往下走进行数据“封装”：</p></blockquote> <ul><li><p><red>应用层</red>通过DNS协议解析域名得到网站的IP地址后，构造一个 HTTP请求报文，然后把报文传递给传输层；</p></li> <li><p><red>传输层</red> 收到报文后，会将请求的数据包进行拆分，打包，并对每个包裹打上tag。在请求报文的基础上，加上一层TCP的首部信息（包括序号和端口号），然后发往网络层；</p></li> <li><p><red>网络层</red> 到了网络层以后，IP协议就发挥了巨大的作用，IP协议中需要两个比较重要的信息，那就是ip地址和mac地址。网络层在首部加入源及目标的IP地址后，将数据段打包成IP数据报，并且在通过ARP协议反向查询到目标主机的mac地址后，一起把数据传递到链路层；</p></li> <li><p><red>链路层</red> 接收IP数据包后添加首部（源以及目标的mac地址等）和尾部封装成帧，并通过网络发送。</p></li></ul> <h3 id="_4-2-优化方案"><a href="#_4-2-优化方案" class="header-anchor">#</a> 4.2 优化方案</h3> <p>针对http请求、减轻服务器压力的优化方案，那就是减少HTTP请求数。</p> <h4 id="静态资源配置cdn"><a href="#静态资源配置cdn" class="header-anchor">#</a> 静态资源配置CDN</h4> <p><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener noreferrer">CDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>就用到了DNS的重定向技术（DNS可以根据服务器运行情况，比如每台机器的负载量，该机器离用户地理位置的距离等等，及时适当的调整调度策略，返回一个合适的服务器IP地址给客户端），CDN返回一个合适的服务器IP地址给客户端，然后CDN节点服务器响应客户端的请求，提供所需的内容。</p> <p>终端用户<code>80-90%</code>的响应时间都花在了下载页面文件（<code>js、css、字体、图片、视频等</code>）上，我们对静态资源配置CDN，不仅可以提高请求的并发数（<code>HTTP1.0/1.1 协议</code>限定单个域名的请求并发量是 6 个），而且能够减轻项目服务器压力，大幅提高用户的响应速度。</p> <h4 id="配置强缓存"><a href="#配置强缓存" class="header-anchor">#</a> 配置强缓存</h4> <p>针对js、css、图片等文件，可以在请求/响应Header的 <code>Cache-Control</code> 属性的 <code>max-age</code> 可以设置一个较长的时间，以便能够减少http请求。</p> <p>浏览器缓存详解，可以点击<a href="/blog/broswer/http-cache.html">查看</a>。</p> <h4 id="懒加载-按需加载"><a href="#懒加载-按需加载" class="header-anchor">#</a> 懒加载，按需加载</h4> <p>很多页面浏览量虽然很大，但其实很大比例用户扫完第一屏就直接跳走了，第一屏以下的内容用户根本就不感兴趣。 对于超大流量的网站，这个问题尤其重要。这时可根据用户的行为对组件、图片、接口等资源进行按需加载，用户用到了就去加载，用不到就不去加载。</p> <h4 id="资源合并"><a href="#资源合并" class="header-anchor">#</a> 资源合并</h4> <p>对于网站里使用的体积不大的图标，可以采用 <code>雪碧图（CSS Sprite）</code> 的方式进行image合并，这样可以大幅度的减少资源请求。</p> <h4 id="inline-images-或-svg"><a href="#inline-images-或-svg" class="header-anchor">#</a> Inline Images 或 SVG</h4> <p>对于体积非常小的图标可以使用 <code>base64</code> 的方式将嵌入到js或css文件中；</p> <p>另外可以使用类似于SVG的字体图标来代替图片。</p> <h4 id="cookie瘦身"><a href="#cookie瘦身" class="header-anchor">#</a> cookie瘦身</h4> <p>http请求header中cookie的大小，会影响http请求速度，我们可以从3个方面去减少当前域http请求携带cookie的大小：</p> <ul><li>缩减整站cookie体积，非必要不使用cookie；</li> <li>给cookie设置合适的域级别和path，以免影响其它子域和页面；</li> <li>设置合适的有效期，更早的有效期或者none可以更快的删除cookie；</li></ul> <h3 id="_4-3-延伸阅读"><a href="#_4-3-延伸阅读" class="header-anchor">#</a> 4.3 延伸阅读</h3> <ul><li><p><a href="/blog/computer/tcp-ip.html">TCP/IP协议四层架构详解</a>：TCP/IP协议中每层协议、功能、及工作原理详细解析。</p></li> <li><p><a href="/blog/broswer/http.html">HTTP详解</a>：详细解析了HTTP协议中各个字段的作用。</p></li></ul> <h2 id="_5-服务器处理请求并返回-http-响应报文"><a href="#_5-服务器处理请求并返回-http-响应报文" class="header-anchor">#</a> 5 服务器处理请求并返回 HTTP 响应报文</h2> <h3 id="_5-1-服务器主机传递http请求报文"><a href="#_5-1-服务器主机传递http请求报文" class="header-anchor">#</a> 5.1 服务器主机传递http请求报文</h3> <p>服务器主机接收完帧数据后，需要从链路层往上走进行数据“分片”：</p> <ul><li><red>链路层</red> 从网络上接收mac帧，抽出IP数据报，交给网络层；</li> <li><red>网络层</red> 接收IP数据报后，抽出TCP报文段，交给传输层；</li> <li><red>传输层</red> 接收TCP报文段后，剥离出HTTP请求报文，交给应用层对应的程序；</li></ul> <h3 id="_5-2-服务器处理请求并返回http响应报文"><a href="#_5-2-服务器处理请求并返回http响应报文" class="header-anchor">#</a> 5.2 服务器处理请求并返回http响应报文</h3> <div class="custom-block tip"><p class="custom-block-title">名称解释</p> <p><red>Web Server</red>，又称web服务器，可以解析HTTP协议。当Web服务器接收到一个HTTP请求(request)，通常会响应一个HTML文件，使浏览器可以浏览。对于不同客户机发送的HTTP请求报文，会结合配置文件，把不同HTTP请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p> <p>每台承载网页的服务器上都会安装处理请求的web服务器。Apache、Tomcat、Nginx、IIS、<a href="https://baike.baidu.com/item/lighttpd" target="_blank" rel="noopener noreferrer">Lighttpd<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 等web服务器监听接收到的请求后，会开启一个子进程或线程池去处理这个请求。</p></div> <p>比如访问<code>www.baidu.com</code>，web服务器在接收到HTTP报文后，会对HTTP报文进行解析（请求方法、域名、路径等），然后进行验证、处理请求。</p> <h4 id="服务器验证流程"><a href="#服务器验证流程" class="header-anchor">#</a> 服务器验证流程</h4> <p>包括：验证是否配置虚拟主机、URL是否接受GET方法、验证该用户是否可以使用GET方法（根据 IP 地址、身份信息等进行安全拦截）等。</p> <p>由于本人对这块具体流程和原理了解不多，在此便不作具体分析。</p> <h4 id="处理请求"><a href="#处理请求" class="header-anchor">#</a> 处理请求</h4> <p>验证通过之后，然后会查看<code>URL重写规则</code>：</p> <ul><li>如果URL配置了 <code>HTTP重定向</code>（重定向也可能不会进行URL重写，得看具体服务器配置。作用是：SEO、短链转长链、防止盗链、自动语言转换等），就会返回一个 301/302 重定向响应，浏览器就会根据响应，重新发送 HTTP 请求。</li> <li>如果没有进行 <code>URL重写</code>，并且请求的URL是一个真实存在的文件（比如图片、html、css、js文件等），服务器检查 HTTP 请求头是否包含<code>If-Modified-Since</code>、<code>If-No-Match</code> 等缓存验证信息决定是否进行 <code>协商缓存</code>。如果资源无更新，继续使用本地缓存文件；否则，会直接把这个文件返回。</li> <li>否则服务器会结合配置文件，把不同HTTP请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</li></ul> <h3 id="_5-3-优化方案"><a href="#_5-3-优化方案" class="header-anchor">#</a> 5.3 优化方案</h3> <h4 id="web服务器配置反向代理"><a href="#web服务器配置反向代理" class="header-anchor">#</a> web服务器配置反向代理</h4> <p><img src="/assets/img/reverse-proxy.7a99407d.png" alt="反向代理">
以nginx服务器为例，如果配置了反向代理：</p> <ul><li>nginx服务器则会在缓存中查找请求内容，找到直接返回客户端；</li> <li>nginx服务器未找到请求内容，则将请求代理至相应的服务器；</li> <li>相应服务器处理请求并返回请求信息给nginx服务器，nginx服务器将请求信息返回给用户。</li></ul> <h5 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h5> <ul><li>保护服务器，外网只能访问到反向代理服务器，对真正提供服务的服务器起到了保护的作用</li> <li>节约ip资源</li> <li>负载均衡，减少WEB服务器压力，提高响应速度</li> <li>解决ajax跨域问题</li> <li>可对所有请求进行的统一控制；</li> <li>……</li></ul> <h4 id="服务端微服务化或配置服务器集群"><a href="#服务端微服务化或配置服务器集群" class="header-anchor">#</a> 服务端微服务化或配置服务器集群</h4> <blockquote><p>不知道大家有没有思考过一个问题: 访问某个大型网站DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？</p></blockquote> <p>服务端可以通过两种方案来满足海量请求：</p> <ul><li>一种是根据网站或服务的实际访问量，配置多台服务器或服务器集群，实现请求的负载均衡；</li> <li>另一种是针对业务属性/数据模型的不同，将大型服务拆分多个微服务，然后根据服务访问规模，配置不同量级的服务器。</li></ul> <h4 id="避免重定向"><a href="#避免重定向" class="header-anchor">#</a> 避免重定向</h4> <p>避免重定向，可以减少一个HTTP往返时长和跳转的时间。可以在服务器中进行设置来避免它。</p> <h4 id="杜绝404"><a href="#杜绝404" class="header-anchor">#</a> 杜绝404</h4> <p>HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。</p> <h4 id="页面主数据获取使用get"><a href="#页面主数据获取使用get" class="header-anchor">#</a> 页面主数据获取使用GET</h4> <p>使用 XMLHttpRequest 时,浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头,在发送数据。</p> <p>所以最好用GET请求,它只需要发送一个TCP报文(除非cookie特别多)。</p> <h4 id="请求文件带上etag"><a href="#请求文件带上etag" class="header-anchor">#</a> 请求文件带上ETag</h4> <p>ETag是文件指纹（基于文件内容的MD5，由服务器端生成），用户端请求文件时在http请求头带上<code>If-No-Match</code>参数，值为ETag字符串，服务器发现是最新的文件不需要更新，则会命中协商缓存，响应一个304 Not Modified的状态码，这样就加快了响应速度。</p> <h4 id="使用gzip压缩"><a href="#使用gzip压缩" class="header-anchor">#</a> 使用Gzip压缩</h4> <p>对静态文件如js、css等使用Gzip/deflate压缩，能够减少响应体积，提升响应速度；浏览器在接收响应后，会自动解压。</p> <h2 id="_6-浏览器接收响应并解析渲染页面"><a href="#_6-浏览器接收响应并解析渲染页面" class="header-anchor">#</a> 6 浏览器接收响应并解析渲染页面</h2> <h3 id="_6-1-接收响应"><a href="#_6-1-接收响应" class="header-anchor">#</a> 6.1 接收响应</h3> <p>HTTP响应报文结构：</p> <div class="language-md extra-class"><pre class="language-md"><code>  <span class="token list punctuation">-</span> 状态行（Status Line）：HTTP协议版本、状态码、响应状态信息（如：HTTP/1.1 200 OK）
  <span class="token list punctuation">-</span> 首部行（Response Header）：用来说明浏览器、服务器或报文主体的一些信息。由 参数/值 对组成
  <span class="token list punctuation">-</span> 响应正文：服务端返回的具体数据信息
</code></pre></div><p>当网络线程接收到响应头数据之后，会执行下面的操作：</p> <ol><li>对资源进行分析，首先解析 响应头，并将响应头解析数据转发到浏览器进程，然后浏览器进程根据不同状态码做不同的事（比如上面提到的重定向）。</li> <li>接下来，浏览器进程根据响应头里的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener noreferrer">MIME类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>去解析响应内容（比如 HTML、图片、字体、PDF等各有不同的解析方式）。<red>比如：假如响应头中<code>Content-Type</code> 的值是<code>text/html</code>，那么浏览器进程就会判断这是一个 HTML 类型的文件， 发送 <code>“CommitNavigation(提交导航)”</code> 消息到渲染进程。渲染进程接收到<code>“CommitNavigation”</code> 消息后，便会和网络线程之间建立一个共享数据的管道，网络线程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。</red>你可以把这个管道想象成一个“水管”，网络线程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 <code>HTML 解析器</code>，它会动态接收字节流，并将其解析为 DOM。
<ul><li>如果响应资源进行了压缩（比如 gzip），浏览器还需要进行解压；</li> <li>在将数据传递给渲染进程之前，网络线程要先检查数据的安全性，这里也是浏览器保证安全的地方。如果返回的数据来自一些恶意的站点，网络线程会显示警告的页面。同时，<code>Cross Origin Read Blocking(CORB)</code> 策略也会确保跨域的敏感数据不会被传递给渲染进程；</li> <li>当所有的检查结束后，网络线程确信浏览器可以访问站点时，网络线程通知UI线程数据已经准备好了。UI线程会根据当前的站点找到一个渲染进程完成接下来的渲染工作；</li></ul></li> <li>最后，响应资源接收完成之后，浏览器进程会对响应资源进行缓存（将返回的请求结果和缓存标识存入浏览器缓存中）。</li></ol> <h3 id="_6-2-解析渲染页面"><a href="#_6-2-解析渲染页面" class="header-anchor">#</a> 6.2 解析渲染页面</h3> <blockquote><p>HTML解析器并不是等整个文档加载完成之后再解析的，而是网络线程加载了多少数据，HTML 解析器便解析多少数据。</p></blockquote> <p>解析HTML，CSS，构建DOM树和RenderObject树，布局分层和生成绘制列表等过程，都是在渲染进程上的主线程中执行的，如果解析HTML、构建DOM树过程中遇到JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JS代码执行完毕（在JS引擎线程中运行），浏览器再从中断的地方恢复DOM构建的执行。</p> <p>想了解浏览器解析HTML到页面呈现到屏幕上的详细过程，请查看<a href="/blog/broswer/render-mechanism.html#_2-渲染引擎核心过程">浏览器渲染原理篇</a>。</p> <p>如果想了解浏览器解析HTML过程中，JavaScript引擎的执行机制及原理，请查看<a href="/blog/broswer/js-mechanism.html">JS执行机制篇</a>。</p> <h3 id="_6-3-优化方案"><a href="#_6-3-优化方案" class="header-anchor">#</a> 6.3 优化方案</h3> <h4 id="预加载"><a href="#预加载" class="header-anchor">#</a> 预加载</h4> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>script<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 或 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modulepreload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 或 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h5 id="preload"><a href="#preload" class="header-anchor">#</a> preload</h5> <blockquote><p>preload的字体资源必须设置crossorigin属性，否则会导致重复加载。原因是如果不指定crossorigin属性(即使同源)，浏览器会采用匿名模式的CORS去preload，导致两次请求无法共用缓存。</p></blockquote> <p>preload是一个预加载关键字。当浏览器“看”到这样的声明后，就会以一定的优先级在后台加载资源。加载完的资源放在HTTP缓存中。而等到要真正执行时，再按照正常方式用标签或者js代码加载，即可从HTTP缓存取出资源。实现了资源的加载和执行分离。</p> <p>preload 是确定性会加载指定资源，比如在某个场景中，main.js 初始化后一定会加载 login.js 和 tabs.js, 则可以使用 preload 预先加载login.js和tabs.js；</p> <p>详细使用指南可以前往<a href="https://juejin.cn/post/6844903562070196237" target="_blank" rel="noopener noreferrer">用 preload 预加载页面资源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h5 id="modulepreload"><a href="#modulepreload" class="header-anchor">#</a> modulepreload</h5> <p>modulepreload 和 preload 的功能一样，不过，前者是针对 module scripts 的，截止到2022.10月，只有 74.51% 的支持率。</p> <p>Vite 有一个特性，自动为它的入口 chunk 和它的直接引用生成 modulepreload。同时，在 vite 的打包配置中，有 <code>build.polyfillModulePreload</code> 这个配置。开启了它，就会自动给浏览器注入下面一段代码:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">'vite/modulepreload-polyfill'</span>
</code></pre></div><p>这段代码就是为了兼容那些不知道 ModulePreload 的浏览器。</p> <h5 id="prefetch"><a href="#prefetch" class="header-anchor">#</a> prefetch</h5> <p>要求浏览器在浏览器空闲时后台下载和缓存资源（如脚本或样式表或图片），下载以低优先级进行，因此不会干扰更重要的资源。当你知道在后续页面/组件需要该资源并且希望提前缓存时，可以使用 <code>prefetch</code>。</p> <p>详细使用指南可以前往<a href="https://juejin.cn/post/6893681741240909832" target="_blank" rel="noopener noreferrer">使用 Preload&amp;Prefetch 优化前端页面的资源加载<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h4 id="使用-async-或-defer"><a href="#使用-async-或-defer" class="header-anchor">#</a> 使用 async 或 defer</h4> <blockquote><p>由于同步脚本会延迟 DOM 构建和呈现，因此您应该始终异步加载第三方脚本，除非脚本必须在页面呈现之前运行。</p></blockquote> <p>async 和 defer 属性告诉浏览器其可以在后台加载脚本时继续解析 HTML，然后在加载后执行脚本。这样，脚本下载不会阻止 DOM 构建和页面呈现。</p> <p>详细使用指南可以前往<a href="https://juejin.cn/post/6894629999215640583" target="_blank" rel="noopener noreferrer">图解 script 标签中的 async 和 defer 属性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h5 id="async"><a href="#async" class="header-anchor">#</a> async</h5> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>script.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>具有 async 属性的脚本在完成下载后和窗口加载事件之前第一时间执行。这意味着 async 脚本可能（并且很可能）不会按照它们在 HTML 中出现的顺序执行。这也意味着如果它们在解析器仍在工作时完成下载，他们可以中断 DOM 构建。
<img src="https://web-dev.imgix.net/image/admin/tCqsJ3E7m4lpKOprXu5B.png?auto=format&amp;w=1600" alt="async">
如果在加载过程中更早地运行脚本很重要，请使用 async。</p> <h5 id="defer"><a href="#defer" class="header-anchor">#</a> defer</h5> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">defer</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>script.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>具有 defer 属性的脚本在 HTML 解析完全完成之后执行，但在 DOMContentLoaded 事件之前执行。defer 保证脚本将按照它们在 HTML 中出现的顺序执行并且不会阻塞解析器。
<img src="https://web-dev.imgix.net/image/admin/Eq0mcvDALKibHe15HspN.png?auto=format&amp;w=1600" alt="defer">
对不太重要的资源使用 defer。例如，低于首屏的视频播放器。</p> <h4 id="把样式表放在顶部-脚本放在body底部"><a href="#把样式表放在顶部-脚本放在body底部" class="header-anchor">#</a> 把样式表放在顶部，脚本放在body底部</h4> <p>把css文件放到<code>&lt;head&gt;</code>标签内部前面，js放到<code>&lt;body&gt;</code>标签最后引入，这样就能尽量避免DOM的构建时长受到JS的影响。</p> <h4 id="减少dom元素的数量"><a href="#减少dom元素的数量" class="header-anchor">#</a> 减少DOM元素的数量</h4> <p>一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 计算页面全部的元素个数</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length
</code></pre></div><p>当页面上存在大量DOM元素时，我们需要清理有些与内容无关的标签，以及用css修复布局问题而非使用div嵌套。</p> <h4 id="尽量减少dom访问"><a href="#尽量减少dom访问" class="header-anchor">#</a> 尽量减少DOM访问</h4> <p>用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：</p> <ul><li>缓存已访问过的元素的索引</li> <li>先“离线”更新节点，再把它们添到DOM树上</li> <li>避免用JavaScript修复布局问题</li></ul> <h4 id="尽量少用iframe"><a href="#尽量少用iframe" class="header-anchor">#</a> 尽量少用iframe</h4> <p>iframe的缺点：</p> <ul><li>代价高昂，即使是空白的iframe</li> <li>阻塞页面加载
我们应该尽量少用iframe。</li></ul> <h4 id="事件委托"><a href="#事件委托" class="header-anchor">#</a> 事件委托</h4> <p>有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。</p> <p>如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。</p> <h4 id="不要用html缩放图片"><a href="#不要用html缩放图片" class="header-anchor">#</a> 不要用HTML缩放图片</h4> <p>不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100<span class="token punctuation">&quot;</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>100<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx.jpg<span class="token punctuation">&quot;</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>那么图片本身（xxx.jpg）应该是 100<em>100px 的，而不是去缩小 500</em>500px 的图片。</p> <h2 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h2> <p><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener noreferrer">http权威指南<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener noreferrer">How browsers work<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://web.dev/howbrowserswork" target="_blank" rel="noopener noreferrer">浏览器的工作原理：新式网络浏览器幕后揭秘<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://book.douban.com/subject/25910556/" target="_blank" rel="noopener noreferrer">WebKit技术内幕<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener noreferrer">从输入 URL 到页面加载完成的过程中都发生了什么事情？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/7128400578467594248" target="_blank" rel="noopener noreferrer">性能优化之 preload、prefetch、preconnect 的区别与使用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://web.dev/efficiently-load-third-party-javascript" target="_blank" rel="noopener noreferrer">高效加载第三方 JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://web.dev/fast/" target="_blank" rel="noopener noreferrer">快速加载<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/broswer/https.html" class="prev">
        深入理解HTTPS
      </a></span> <span class="next"><a href="/blog/broswer/render-mechanism.html">
        浏览器渲染原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.237e33b5.js" defer></script><script src="/assets/js/2.a6e094ff.js" defer></script><script src="/assets/js/14.6926c1c5.js" defer></script>
  </body>
</html>
