<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>合成层详解 | crise&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./assets/logo.png">
    <meta name="description" content="一名程序员/前端人的技术博客">
    
    <link rel="preload" href="/assets/css/0.styles.567624d3.css" as="style"><link rel="preload" href="/assets/js/app.92dc81f6.js" as="script"><link rel="preload" href="/assets/js/2.2d54ebdc.js" as="script"><link rel="preload" href="/assets/js/12.4e876679.js" as="script"><link rel="prefetch" href="/assets/js/10.01084cac.js"><link rel="prefetch" href="/assets/js/11.bac0121f.js"><link rel="prefetch" href="/assets/js/13.d3fce123.js"><link rel="prefetch" href="/assets/js/14.75510bd2.js"><link rel="prefetch" href="/assets/js/15.48750021.js"><link rel="prefetch" href="/assets/js/16.7952a809.js"><link rel="prefetch" href="/assets/js/17.10b72fbd.js"><link rel="prefetch" href="/assets/js/18.13c83f7d.js"><link rel="prefetch" href="/assets/js/19.31948ab8.js"><link rel="prefetch" href="/assets/js/20.dc4c0c1c.js"><link rel="prefetch" href="/assets/js/21.1b255fe0.js"><link rel="prefetch" href="/assets/js/22.2f1d66a8.js"><link rel="prefetch" href="/assets/js/23.cf0fa840.js"><link rel="prefetch" href="/assets/js/24.9cf68851.js"><link rel="prefetch" href="/assets/js/25.c501abdb.js"><link rel="prefetch" href="/assets/js/26.5f6dd563.js"><link rel="prefetch" href="/assets/js/27.74260c5a.js"><link rel="prefetch" href="/assets/js/28.ce8f13bc.js"><link rel="prefetch" href="/assets/js/29.06bdce57.js"><link rel="prefetch" href="/assets/js/3.e9d5348e.js"><link rel="prefetch" href="/assets/js/30.8204335f.js"><link rel="prefetch" href="/assets/js/31.01971e34.js"><link rel="prefetch" href="/assets/js/32.c9d7df95.js"><link rel="prefetch" href="/assets/js/33.96b6de7c.js"><link rel="prefetch" href="/assets/js/34.b813165e.js"><link rel="prefetch" href="/assets/js/35.615aded7.js"><link rel="prefetch" href="/assets/js/36.9c619b20.js"><link rel="prefetch" href="/assets/js/37.90ffb782.js"><link rel="prefetch" href="/assets/js/38.1967fbbd.js"><link rel="prefetch" href="/assets/js/39.0d735efe.js"><link rel="prefetch" href="/assets/js/4.ca421095.js"><link rel="prefetch" href="/assets/js/40.923e5594.js"><link rel="prefetch" href="/assets/js/41.fd7797b4.js"><link rel="prefetch" href="/assets/js/42.7177cfca.js"><link rel="prefetch" href="/assets/js/43.b745c235.js"><link rel="prefetch" href="/assets/js/44.6fa2e561.js"><link rel="prefetch" href="/assets/js/45.9ecc0f19.js"><link rel="prefetch" href="/assets/js/46.d47edb5a.js"><link rel="prefetch" href="/assets/js/47.f48a72bc.js"><link rel="prefetch" href="/assets/js/48.19da9fb3.js"><link rel="prefetch" href="/assets/js/49.a5d16804.js"><link rel="prefetch" href="/assets/js/5.1898d05c.js"><link rel="prefetch" href="/assets/js/50.5efb3589.js"><link rel="prefetch" href="/assets/js/51.6a21aa98.js"><link rel="prefetch" href="/assets/js/52.2947ff47.js"><link rel="prefetch" href="/assets/js/53.dc63262e.js"><link rel="prefetch" href="/assets/js/54.fa9b8371.js"><link rel="prefetch" href="/assets/js/55.d0f31e05.js"><link rel="prefetch" href="/assets/js/56.de8ec14d.js"><link rel="prefetch" href="/assets/js/57.73331274.js"><link rel="prefetch" href="/assets/js/58.4f67425f.js"><link rel="prefetch" href="/assets/js/59.318ec5bd.js"><link rel="prefetch" href="/assets/js/6.c999d008.js"><link rel="prefetch" href="/assets/js/60.f6a602f9.js"><link rel="prefetch" href="/assets/js/61.c659faf6.js"><link rel="prefetch" href="/assets/js/62.4ccc91f2.js"><link rel="prefetch" href="/assets/js/63.6e5e36a9.js"><link rel="prefetch" href="/assets/js/64.2660e08e.js"><link rel="prefetch" href="/assets/js/65.b06b0bed.js"><link rel="prefetch" href="/assets/js/66.1f836a7a.js"><link rel="prefetch" href="/assets/js/67.add88f29.js"><link rel="prefetch" href="/assets/js/68.e74a51fc.js"><link rel="prefetch" href="/assets/js/69.63126800.js"><link rel="prefetch" href="/assets/js/7.92efcfae.js"><link rel="prefetch" href="/assets/js/70.1dc8f877.js"><link rel="prefetch" href="/assets/js/71.856f3fe1.js"><link rel="prefetch" href="/assets/js/72.927e4ce2.js"><link rel="prefetch" href="/assets/js/73.2c1e909e.js"><link rel="prefetch" href="/assets/js/74.c8b565d2.js"><link rel="prefetch" href="/assets/js/75.00537c0a.js"><link rel="prefetch" href="/assets/js/76.492fbce1.js"><link rel="prefetch" href="/assets/js/77.6fb48b9b.js"><link rel="prefetch" href="/assets/js/78.d5aea725.js"><link rel="prefetch" href="/assets/js/8.81eb0648.js"><link rel="prefetch" href="/assets/js/9.1bebc5a8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.567624d3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">crise's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="https://baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法题库
</a></div><div class="nav-item"><a href="https://baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浏览器</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/broswer/broswer-framework.html" class="sidebar-link">一文搞定浏览器架构</a></li><li><a href="/blog/broswer/kernel.html" class="sidebar-link">一文看懂浏览器内核</a></li><li><a href="/blog/broswer/useragent.html" class="sidebar-link">浏览器和UserAgent发展史</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>原理篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/broswer/website-navigation.html" class="sidebar-link">从浏览器输入网址到页面加载，中间发生了什么？</a></li><li><a href="/blog/broswer/render-mechanism.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/blog/broswer/compositor-layer-manage.html" aria-current="page" class="active sidebar-link">合成层详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#为什么需要graphicslayer" class="sidebar-link">为什么需要GraphicsLayer？</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#合成层提升规则" class="sidebar-link">合成层提升规则</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#直接原因-direct-reason" class="sidebar-link">直接原因（direct reason）</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#后代元素原因" class="sidebar-link">后代元素原因</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#overlap-重叠原因" class="sidebar-link">overlap 重叠原因</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#合成层调试" class="sidebar-link">合成层调试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#compositing-reason-合成原因" class="sidebar-link">Compositing Reason — 合成原因</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#层消耗内存" class="sidebar-link">层消耗内存</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#层爆炸与层压缩" class="sidebar-link">层爆炸与层压缩</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#层压缩" class="sidebar-link">层压缩</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#层爆炸" class="sidebar-link">层爆炸</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#性能优化" class="sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#提升动画效果的元素" class="sidebar-link">提升动画效果的元素</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#css3硬件加速" class="sidebar-link">css3硬件加速</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#避免隐式合成" class="sidebar-link">避免隐式合成</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#减少绘制区域" class="sidebar-link">减少绘制区域</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#最后-合理管理合成层" class="sidebar-link">最后 — 合理管理合成层</a></li><li class="sidebar-sub-header"><a href="/blog/broswer/compositor-layer-manage.html#参考文档" class="sidebar-link">参考文档</a></li></ul></li><li><a href="/blog/broswer/reflow-repaint-composite.html" class="sidebar-link">重排、重绘与合成</a></li><li><a href="/blog/broswer/js-mechanism.html" class="sidebar-link">JS执行机制</a></li><li><a href="/blog/broswer/v8-execute.html" class="sidebar-link">V8执行JavaScript原理</a></li><li><a href="/blog/broswer/http-cache.html" class="sidebar-link">浏览器缓存机制</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>兼容篇</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/broswer/bfcache.html" class="sidebar-link">浏览器兼容之bfcache</a></li><li><a href="/blog/broswer/compatibility.html" class="sidebar-link">浏览器兼容性问题研究</a></li><li><a href="/blog/broswer/pageshow-visibilitychange.html" class="sidebar-link">pageshow、pagehide、visibilitychange对比</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>web跨端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架与原理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机与网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>运维与安全</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="合成层详解"><a href="#合成层详解" class="header-anchor">#</a> 合成层详解</h1> <p>在<a href="/blog/broswer/render-mechanism.html#_5-分层布局树-生成layer-tree">浏览器渲染原理</a>一文中已经讲过<code>渲染层</code>的概念，在此就不多做赘述。下面我们说下 合成层概念、提升规则、工作原理，优化以及调试手段等。</p> <h2 id="为什么需要graphicslayer"><a href="#为什么需要graphicslayer" class="header-anchor">#</a> 为什么需要GraphicsLayer？</h2> <p>层叠上下文、半透明、mask等等问题通过RenderLayer解决了。但是浏览器里面经常有动画、video、canvas、3d的css等东西。这意味着页面在有这些元素时，页面显示会经常变动，也就意味着位图会经常变动。每秒60帧的动效里，每次变动都重绘整个位图是很恐怖的性能开销。</p> <p>因此浏览器为了优化这一过程。引出了<code>GraphicsLayers</code>和<code>GraphicsContext</code>。</p> <h2 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h2> <blockquote><p>PS: Chrome修改了 “Blink引擎” 的一些实现，某些我们之前熟知的类名有了变化，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer（感兴趣可以查看<a href="https://www.chromium.org/blink/slimming-paint" target="_blank" rel="noopener noreferrer">Slimming Paint<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）。后续文案我们还是依然使用原来的命名进行书写。</p></blockquote> <p>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。</p> <p>每个 GraphicsLayer 都有一个 <code>GraphicsContext</code>，GraphicsContext 负责输出该层的位图（GraphicsContext将<code>RGB图像</code>，<code>GMYK图像</code> 或者 <code>黑白图像</code>绘制到一个位图对象中），位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多层位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。</p> <h2 id="合成层提升规则"><a href="#合成层提升规则" class="header-anchor">#</a> 合成层提升规则</h2> <p>渲染层提升为合成层有一个先决条件，该渲染层必须是 SelfPaintingLayer（基本可认为是<a href="/blog/broswer/render-mechanism.html#_5-分层布局树-生成layer-tree">浏览器渲染原理</a>一文中提到的 NormalPaintLayer）。以下所讨论的渲染层提升为合成层的情况都是在该渲染层为 SelfPaintingLayer 前提下的。</p> <p>一旦一个元素提升为了合成层就会有自己的绘图上下文，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能：</p> <ul><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li> <li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul> <h3 id="直接原因-direct-reason"><a href="#直接原因-direct-reason" class="header-anchor">#</a> 直接原因（direct reason）</h3> <ul><li>硬件加速的 iframe 元素（比如 iframe 嵌入的页面中有合成层）</li> <li>使用加速视频解码的 video 元素</li> <li>覆盖在 video 元素上的视频控制栏</li> <li>拥有 3D（WebGL）上下文或硬件加速的 2D 上下文的 canvas 元素</li> <li>硬件加速的插件，比如 flash 等</li> <li>在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶 <a href="/demo/fixed-transform.html">demo</a></li> <li>3D 或透视变换(perspective transform) CSS 属性，如<code>transform: translateZ(0)</code> 或 <code>transform: translate3d(10px,10px,10px)</code></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/backface-visibility" target="_blank" rel="noopener noreferrer">backface-visibility<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 为 hidden</li> <li>overflow 不为 visible。有需要剪裁(clip)的内容，当内容展示不下被隐藏或出现滚动条时，内容元素 和 滚动条 会提升成合成层</li> <li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change" target="_blank" rel="noopener noreferrer">will-change<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）</li></ul> <h3 id="后代元素原因"><a href="#后代元素原因" class="header-anchor">#</a> 后代元素原因</h3> <ul><li>有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性</li> <li>有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto）</li> <li>有合成层后代同时本身 fixed 定位</li> <li>有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性</li> <li>有 3D transfrom 的合成层后代同时本身有 perspective</li></ul> <h3 id="overlap-重叠原因"><a href="#overlap-重叠原因" class="header-anchor">#</a> overlap 重叠原因</h3> <p>元素有一个兄弟元素在合成层渲染，并且该兄弟元素的 z-index 较小，那这个元素也会被提升到合成层。</p> <h4 id="如何算是重叠"><a href="#如何算是重叠" class="header-anchor">#</a> 如何算是重叠？</h4> <p>那如何算是重叠呢，最常见和容易理解的就是 <em><strong>元素的 border-box（content+padding+border）和合成层的有重叠</strong></em>，当然 margin area 的重叠是无效的。</p> <p>其他的还有一些不常见的情况，也算是同合成层重叠的条件，如下：</p> <ul><li>filter 效果同合成层重叠</li> <li>transform 变换后同合成层重叠</li> <li>overflow scroll 情况下同合成层重叠。即如果一个 overflow scroll（不管 overflow:auto 还是 overflow:scroll，只要是能 scroll 即可） 的元素同一个合成层重叠，则其可视子元素也同该合成层重叠</li></ul> <h4 id="为什么会因为重叠原因而产生合成层呢"><a href="#为什么会因为重叠原因而产生合成层呢" class="header-anchor">#</a> 为什么会因为重叠原因而产生合成层呢？</h4> <p><img src="/assets/img/composite-overlap.d7381e50.png" alt="重叠">
蓝色的矩形重叠在绿色矩形之上，同时它们的父元素是一个 GraphicsLayer。此时假设绿色矩形为一个 GraphicsLayer，如果 overlap 无法提升合成层的话，那么蓝色矩形不会提升为合成层，也就会和父元素公用一个 GraphicsLayer。
<img src="/assets/img/composite-overlap2.437338b2.png" alt="重叠">
此时，渲染顺序就会发生错误，因此为保证渲染顺序，overlap 也成为了合成层产生的原因，也就是如下的正常情形。
<img src="/assets/img/composite-overlap3.b496e67d.png" alt="重叠"></p> <h2 id="合成层调试"><a href="#合成层调试" class="header-anchor">#</a> 合成层调试</h2> <p>使用 Chrome DevTools 工具，通过<code>More tools —&gt; Layers</code>面板，勾选上”Paints“和”Slow scroll rects“可以查看网站具体是如何划分层的。
<img src="/assets/img/layer-border.8dcad124.png" alt="合成层查看">
打开<code>More tools —&gt; Rendering</code>面板，勾选上 <code>Layer borders</code>，页面上的合成层会用青色或黄色边框框出来。</p> <p>有了这个视图，你就能知道页面中到底有多少个合成层，点击 “Layers -&gt; Details -&gt; Paint Profiler”，我们可以查看合成层的具体绘制步骤以及绘制时长。如果你在对页面滚动或渐变效果的性能分析中发现 Composite 过程耗费了太多时间，那么你可以从这个视图里看到页面中有多少个渲染层，它们为何被创建，从而对合成层的数量进行优化。</p> <h3 id="compositing-reason-合成原因"><a href="#compositing-reason-合成原因" class="header-anchor">#</a> Compositing Reason — 合成原因</h3> <ul><li>n/a 表示在合成过程中没有特别需要说明或记录的步骤或原因。这种情况可能发生在以下情况下：
<ul><li>简单合成：当图像或视频的合成过程非常简单，没有需要特别解释的步骤或原因时，就会出现这种情况</li> <li>没有特殊调整：有时，合成过程中可能不需要对图像或视频进行额外的调整或修饰，因此不会有特别的原因或步骤</li> <li>不适用于特定情况：有时候，在记录合成过程中，可能会有某些步骤不适用于特定的情况，因此在那些步骤上可能会标记为 &quot;n/a&quot;</li></ul></li> <li>Has a 3d transform</li> <li>Is an accelerated video</li> <li>Is an accelerated canvas, or is a display list backed canvas that was promoted to a layer based on a performance heuristic.</li> <li>Is an accelerated plugin</li> <li>Is an accelerated iFrame</li> <li>Is an accelerated SVG root</li> <li>Has backface-visibility: hidden</li> <li>Has an active accelerated transform animation or transition</li> <li>Has an active accelerated opacity animation or transition</li> <li>Has an active accelerated filter animation or transition</li> <li>Has an active accelerated backdrop filter animation or transition</li> <li>Is DOM overlay for WebXR immersive-ar mode</li> <li>Is fixed or sticky position</li> <li>Is a scrollable overflow element</li> <li>Scroll parent is not an ancestor</li> <li>Has clipping ancestor</li> <li>Is overlay controls for video</li> <li>Has a will-change: transform compositing hint</li> <li>Has a will-change: opacity compositing hint</li> <li>Has a will-change: filter compositing hint</li> <li>Has a will-change: backdrop-filter compositing hint</li> <li>Has a will-change compositing hint other than transform and opacity</li> <li>Has a backdrop filter</li> <li>Is a mask for backdrop filter</li> <li>Is the document.rootScroller</li> <li>Might overlap other composited content</li> <li>Overlaps other composited content</li> <li>Parent with composited negative z-index content</li> <li>Layer was separately composited because it could not be squashed</li> <li>Has opacity that needs to be applied by compositor because of composited descendants</li> <li>Has a mask that needs to be known by compositor because of composited descendants</li> <li>Has a reflection that needs to be known by compositor because of composited descendants</li> <li>Has a filter effect that needs to be known by compositor because of composited descendants</li> <li>Has a blending effect that needs to be known by compositor because of composited descendants</li> <li>Has a perspective transform that needs to be known by compositor because of 3d descendants</li> <li>Has a preserves-3d property that needs to be known by compositor because of 3d descendants</li> <li>Should isolate descendants to apply a blend effect</li> <li>Is a fullscreen video element with composited descendants</li> <li>Is the root layer</li> <li>Secondary layer, the horizontal scrollbar layer</li> <li>Secondary layer, the vertical scrollbar layer</li> <li>Secondary layer, the scroll corner layer</li> <li>Secondary layer, to house contents that can be scrolled</li> <li>Secondary layer, home for a group of squashable content</li> <li>Secondary layer, to contain any normal flow and positive z-index contents on top of a negative z-index layer</li> <li>Secondary layer, to contain the mask contents</li> <li>Layer painted on top of other layers as decoration</li> <li>Layer for link highlight, frame overlay, etc</li> <li>Ancestor in same 3D rendering context has a hidden backface</li></ul> <h3 id="层消耗内存"><a href="#层消耗内存" class="header-anchor">#</a> 层消耗内存</h3> <p>层合成的过程会产生内存消耗，那么我们如何来评估层消耗的内存，下面举例来说明：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>div1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>div2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
<span class="token selector">#div1, #div2</span> <span class="token punctuation">{</span>
 <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">#div1</span> <span class="token punctuation">{</span>
 <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
 <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
 <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">#div2</span> <span class="token punctuation">{</span>
 <span class="token property">width</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
 <span class="token property">height</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
 <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>10<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如上，我们创建了两个容器 div1 和 div2，div1 的物理尺寸是 <code>100×100px（100×100×3 = 30000 字节）</code>，而 div2 只有 <code>10×10px（10×10×3 = 300 字节）</code> 但放大了 10 倍。 div2 由于存在 <code>will-change</code> 属性，transform 动画将通过 GPU 来渲染图层。 我们通过图像的高度乘以图像的宽度来获得图像中像素的数量。然后，我们将其乘以3，因为每个像素都用三个字节（RGB）描述。那么不难理解，如果图像包含透明区域，我们要乘以4，因为需要额外的字节来描述透明度：（RGBA）：100×100×4 = 40000 字节。</p> <p>所以，对于图片和纯色层元素，我们可以将图片或元素的尺寸减少到原始的5%——10%，然后使用scale将它们放大；用户不会看到什么区别，但是你可以减少资源请求耗时和大量的存储空间。</p> <h2 id="层爆炸与层压缩"><a href="#层爆炸与层压缩" class="header-anchor">#</a> 层爆炸与层压缩</h2> <h3 id="层压缩"><a href="#层压缩" class="header-anchor">#</a> 层压缩</h3> <p>由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了<code>层压缩（Layer Squashing）</code>的处理。如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。</p> <p>浏览器的自动的层压缩也不是万能的，有很多特定情况下，浏览器是无法进行层压缩的。 如下所示，而这些情况也是我们应该尽量避免的：</p> <ul><li>无法进行会打破渲染顺序的压缩</li> <li>video 元素的渲染层无法被压缩同时也无法将别的渲染层压缩到 video 所在的合成层上</li> <li>iframe、plugin 的渲染层无法被压缩同时也无法将别的渲染层压缩到其所在的合成层上</li> <li>无法压缩有 reflection 属性的渲染层（squashingReflectionDisallowed）</li> <li>无法压缩有 blend mode 属性的渲染层（squashingBlendingDisallowed）</li> <li>当渲染层同合成层有不同的裁剪容器（clipping container）时，该渲染层无法压缩（squashingClippingContainerMismatch）</li> <li>相对于合成层滚动的渲染层无法被压缩（scrollsWithRespectToSquashingLayer）</li> <li>当渲染层同合成层有不同的具有 opacity 的祖先层（一个设置了 opacity 且小于 1，一个没有设置 opacity，也算是不同）时，该渲染层无法压缩（squashingOpacityAncestorMismatch，同 squashingClippingContainerMismatch）</li> <li>当渲染层同合成层有不同的具有 transform 的祖先层时，该渲染层无法压缩（squashingTransformAncestorMismatch，同上）</li> <li>当渲染层同合成层有不同的具有 filter 的祖先层时，该渲染层无法压缩（squashingFilterAncestorMismatch，同上）</li> <li>当覆盖的合成层正在运行动画时，该渲染层无法压缩（squashingLayerIsAnimating），当动画未开始或者运行完毕以后，该渲染层才可以被压缩</li></ul> <p>如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。</p> <h3 id="层爆炸"><a href="#层爆炸" class="header-anchor">#</a> 层爆炸</h3> <p><em><strong>层爆炸，指的是由于重叠而导致的大量额外 Composited Layer 的问题</strong></em>。通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。</p> <p>解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠，譬如巧妙的使用 <code>z-index</code> 属性。</p> <h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <p>提升为合成层简单说来有以下几点好处：</p> <ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li> <li>当需要 repaint 时，只需要 repaint 自身合成层，不会影响到其他的合成层</li> <li>对于 transform 和 opacity 效果，不会触发 layout 和 paint
利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。</li></ul> <h3 id="提升动画效果的元素"><a href="#提升动画效果的元素" class="header-anchor">#</a> 提升动画效果的元素</h3> <p>提升合成层的最好方式是使用 CSS 的 will-change 属性。从合成层提升规则一节，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
    <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是兼容性不太好，对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但需要注意的是，不要创建太多的渲染层。因为每创建一个新的渲染层，就意味着新的内存分配和更复杂的层管理。之后我们会详细讨论。</p> <p>如果你已经把一个元素放到一个新的合成层里，那么可以使用 <code>Performance ——&gt; Timeline</code> 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。</p> <h3 id="css3硬件加速"><a href="#css3硬件加速" class="header-anchor">#</a> css3硬件加速</h3> <div class="custom-block tip"><p class="custom-block-title">硬件加速</p> <p>GPU（Graphics Processing Unit） 是图像处理器。GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。 GPU 加速可以不仅应用于3D，而且也可以应用于2D。这里， GPU 加速通常包括以下几个部分：Canvas2D，布局合成（Layout Compositing）, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。</p></div> <p>使用css3硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起重排和重绘。但是对于动画的其它属性，比如<code>background-color</code>这些，还是会引起重排和重绘的，不过它还是可以提升这些动画的性能。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/*
 * 根据上面的结论
 * 将 2d transform 换成 3d
 * 就可以强制开启 GPU 加速
 * 提高动画性能
 */</span>
<span class="token selector">div</span> <span class="token punctuation">{</span>
    <span class="token comment">/* transform: translate(10px, 10px); */</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate3d</span><span class="token punctuation">(</span>10px<span class="token punctuation">,</span> 10px<span class="token punctuation">,</span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题，我们应该避免引起隐式合成层的提升。另外在动画结束的时候得关闭硬件加速，不然会产生字体模糊（由于GPU和CPU的算法的不同，在GPU渲染字体会导致抗锯齿无效）。</p> <h3 id="避免隐式合成"><a href="#避免隐式合成" class="header-anchor">#</a> 避免隐式合成</h3> <p>保持动画的对象的z-index尽可能的高，这样可以尽量避免兄弟元素被隐式的提升成合成层。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。</p> <p>将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。</p> <h3 id="减少绘制区域"><a href="#减少绘制区域" class="header-anchor">#</a> 减少绘制区域</h3> <p>对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域。</p> <p>举个🌰：一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。</p> <p>而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。</p> <p>减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</p> <h2 id="最后-合理管理合成层"><a href="#最后-合理管理合成层" class="header-anchor">#</a> 最后 — 合理管理合成层</h2> <p>看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p> <h2 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h2> <p><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener noreferrer">GPU Accelerated Compositing in Chrome<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://fed.taobao.org/blog/taofed/do71ct/performance-composite" target="_blank" rel="noopener noreferrer">无线性能优化：Composite<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/broswer/render-mechanism.html" class="prev">
        浏览器渲染原理
      </a></span> <span class="next"><a href="/blog/broswer/reflow-repaint-composite.html">
        重排、重绘与合成
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.92dc81f6.js" defer></script><script src="/assets/js/2.2d54ebdc.js" defer></script><script src="/assets/js/12.4e876679.js" defer></script>
  </body>
</html>
