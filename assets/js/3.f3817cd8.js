(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{438:function(t,e,a){t.exports=a.p+"assets/img/dom-build.a3350184.png"},439:function(t,e,a){t.exports=a.p+"assets/img/token-stack.5767a760.png"},440:function(t,e,a){t.exports=a.p+"assets/img/dom-generate.2b35db1f.png"},441:function(t,e,a){t.exports=a.p+"assets/img/cssom-process.458221b1.png"},442:function(t,e,a){t.exports=a.p+"assets/img/css-normalize.06c7f9c9.png"},443:function(t,e,a){t.exports=a.p+"assets/img/cssom.0872903e.png"},444:function(t,e,a){t.exports=a.p+"assets/img/css-block.82251ee4.png"},445:function(t,e,a){t.exports=a.p+"assets/img/css-block-js.b883923f.png"},446:function(t,e,a){t.exports=a.p+"assets/img/layout-to-layer.020839dc.png"},447:function(t,e,a){t.exports=a.p+"assets/img/stack-context.a828ebe4.png"},448:function(t,e,a){t.exports=a.p+"assets/img/clip-property.be08706a.png"},449:function(t,e,a){t.exports=a.p+"assets/img/tile.d1d3ffe6.png"},450:function(t,e,a){t.exports=a.p+"assets/img/bitmap.c02c7958.png"},451:function(t,e,a){t.exports=a.p+"assets/img/raster.3ed34e9a.png"},452:function(t,e,a){t.exports=a.p+"assets/img/render-flow.991e4bae.png"},453:function(t,e,a){t.exports=a.p+"assets/img/paint-records.d58bb5e7.png"},454:function(t,e,a){t.exports=a.p+"assets/img/raster-threads.0fd74671.png"},455:function(t,e,a){t.exports=a.p+"assets/img/draw-quads.fe58329f.png"},456:function(t,e,a){t.exports=a.p+"assets/img/event-interaction.c3d38f71.png"},457:function(t,e,a){t.exports=a.p+"assets/img/non-fast-scrollable.69291772.png"},458:function(t,e,a){t.exports=a.p+"assets/img/paint-records-draw.07530866.png"},459:function(t,e,a){t.exports=a.p+"assets/img/defeat-scroll-region.0128029d.png"},460:function(t,e,a){t.exports=a.p+"assets/img/event-flooding-junk.924556ad.png"},461:function(t,e,a){t.exports=a.p+"assets/img/event-coalesced-delayed.5a03e274.png"},533:function(t,e,a){"use strict";a.r(e);var s=a(65),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器渲染原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染原理"}},[t._v("#")]),t._v(" 浏览器渲染原理")]),t._v(" "),s("p",[t._v("本质上，浏览器的渲染过程，就是根据描述或定义构建数学模型，通过模型生成图像的过程。而当用户与页面发生交互动作时，则显示新的图像。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://web.dev/static/articles/howbrowserswork/image/webkit-main-flow-b779d50c0cf28_1920.png",alt:"webkit渲染流程"}})]),t._v(" "),s("p",[t._v("上图是经典的"),s("code",[t._v("webkit")]),t._v("渲染流程，不同的浏览器渲染引擎，渲染过程不完全相同，但大致流程都差不多。然而伴随着现代浏览器的发展，渲染引擎架构也相应的发生了一些变化。")]),t._v(" "),s("p",[t._v("以现在的Chrome浏览器为例，渲染页面的过程大致分为以下6个步骤：")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("根据HTML解析生成DOM树")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("根据CSS解析生成CSS规则树")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("结合DOM树和CSS规则树，生成渲染树")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("布局渲染树，生成Layout Tree")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"5"}},[s("li",[t._v("分层布局树，生成Layer Tree")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"6"}},[s("li",[t._v("绘制与合成\n")])])])]),t._v(" "),s("p",[t._v("前面5个步骤都是在渲染进程中的 "),s("code",[t._v("主线程")]),t._v(" 中进行的，最后一步则由渲染进程的"),s("code",[t._v("合成线程")]),t._v("、"),s("code",[t._v("栅格线程")]),t._v("完成图像的绘制工作，最终GPU合成页面后，drawing 到屏幕上。")]),t._v(" "),s("h2",{attrs:{id:"_1-根据html解析生成dom树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-根据html解析生成dom树"}},[t._v("#")]),t._v(" 1. 根据HTML解析生成DOM树")]),t._v(" "),s("p",[t._v("浏览器解析html是从上往下一行一行地解析的。当解析到script标签时，会暂停DOM构建，等待脚本下载并执行完毕，才会继续向下解析。js脚本会阻塞DOM解析，进而影响页面渲染速度。")]),t._v(" "),s("p",[t._v("当整个解析的过程完成以后，浏览器会通过"),s("code",[t._v("DOMContentLoaded")]),t._v("事件来通知DOM解析完成。")]),t._v(" "),s("h3",{attrs:{id:"_1-1-子资源加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-子资源加载"}},[t._v("#")]),t._v(" 1.1 子资源加载")]),t._v(" "),s("p",[t._v("在构建DOM的过程中，会解析到图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，逐一发起请求去获取。但是为了提升速度，Webkit和Firefox针对js脚本下载阻塞DOM解析都做了很多优化，其中一个主要的优化是预解析操作。")]),t._v(" "),s("p",[t._v("浏览器会运行"),s("code",[t._v("预加载扫描器（preload scanner）")]),t._v("对HTML文档进行快速扫描（这个扫描过程不需要完全解析整个HTML文档，而是仅识别文档的基本结构和关键元素），如果HTML中存在"),s("code",[t._v("img")]),t._v("、"),s("code",[t._v("link")]),t._v("、"),s("code",[t._v("script")]),t._v("等标签，它会查看html解析器生成的Token，解析到相关文件之后，预加载扫描器会把这些请求传递给"),s("code",[t._v("Network Process")]),t._v("提前进行资源下载。")]),t._v(" "),s("h3",{attrs:{id:"_1-2-解析dom流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-解析dom流程"}},[t._v("#")]),t._v(" 1.2 解析DOM流程")]),t._v(" "),s("p",[t._v("解析的过程可以分为以下四个步骤：\n"),s("img",{attrs:{src:a(438),alt:"DOM树构建"}})]),t._v(" "),s("h4",{attrs:{id:"解码-decoding"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解码-decoding"}},[t._v("#")]),t._v(" 解码（decoding）")]),t._v(" "),s("p",[t._v("HTML解析器接收到管道传输回来的二进制字节流之后，先根据文件charset指定编码（例如UTF-8）转换成字符串，也就是HTML代码。")]),t._v(" "),s("h4",{attrs:{id:"符号化-tokenization"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号化-tokenization"}},[t._v("#")]),t._v(" 符号化（Tokenization）")]),t._v(" "),s("blockquote",[s("p",[t._v('浏览器容错进制：你从来没有在浏览器看过类似"语法无效"的错误，这是因为浏览器去纠正错误的语法，然后继续工作。')])]),t._v(" "),s("p",[s("strong",[t._v("符号化是词法分析的过程，将字符串解析成符号（Token）")]),t._v("，HTML 符号包括："),s("code",[t._v("开始标签(StartTag)")]),t._v("、"),s("code",[t._v("结束标签(EndTag)")]),t._v("、"),s("code",[t._v("文本标签(textTag)")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(439),alt:"Token栈"}})]),s("figcaption",[t._v("HTML解析器维护了一个Token栈，该Token栈主要用来计算节点之间的父子关系，解析生成的Token会按顺序压入栈中")]),s("p"),t._v(" "),s("p",[t._v("Token分为 "),s("code",[t._v("Tag Token")]),t._v(" 和 "),s("code",[t._v("文本 Token")]),t._v("。HTML 解析器开始工作时，会默认创建一个根为 document 的空 DOM 结构，同时会将一个 "),s("code",[t._v("StartTag document")]),t._v(" 的 Token 压入栈底，然后进行不断压栈出栈操作（碰到StartTag会入栈，碰到EndTag会出栈），直到栈空完成解析。\n")]),t._v(" "),s("p",[t._v("具体的词法分析过程可以查看"),s("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/parsing.html#html-parser",target:"_blank",rel:"noopener noreferrer"}},[t._v("符号化及构建树的完整算法"),s("OutboundLink")],1),t._v("。")]),t._v(" "),s("h4",{attrs:{id:"生成nodes并构建dom树-tree-construction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成nodes并构建dom树-tree-construction"}},[t._v("#")]),t._v(" 生成Nodes并构建DOM树（tree construction）")]),t._v(" "),s("blockquote",[s("p",[t._v("ps：符号化和生成Node是并行操作的，也就是说一边进行"),s("code",[t._v("词法解析")]),t._v("生成Token，一边采取"),s("code",[t._v("深度遍历算法")]),t._v("来创建一个 Node 节点。")])]),t._v(" "),s("p",[s("strong",[t._v("浏览器会根据Token里记录的 开始标签和文本标签，创建Node节点")]),t._v("（Node节点包含了html标签的所有属性），然后渲染引擎会把Node节点以合适的方法插入到DOM树中，当Token栈清空完毕，紧接着DOM树也就构建完成。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(440),alt:"DOM树"}})]),t._v(" "),s("h2",{attrs:{id:"_2-根据css解析生成cssom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-根据css解析生成cssom"}},[t._v("#")]),t._v(" 2. 根据CSS解析生成CSSOM")]),t._v(" "),s("h3",{attrs:{id:"_2-1-基础概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-基础概念"}},[t._v("#")]),t._v(" 2.1 基础概念")]),t._v(" "),s("h4",{attrs:{id:"css-继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-继承"}},[t._v("#")]),t._v(" CSS 继承")]),t._v(" "),s("p",[t._v("假如body有一个样式规则是"),s("code",[t._v("font-size: 16px")]),t._v("，之后，body上每个子节点都会继承"),s("code",[t._v("font-size: 16px")]),t._v("这条样式规则。每个子节点都可以在这个样式基础上还会添加自己单独的样式规则，比如span又添加了一个样式规则"),s("code",[t._v("font-size: 14px")]),t._v("。正是因为样式这种类似于继承的特性，浏览器设定了一条规则："),s("em",[s("strong",[t._v("CSSOM Tree需要等到完全构建后才可以被使用，因为后面的属性可能会覆盖掉前面的设置。")])])]),t._v(" "),s("h4",{attrs:{id:"css-层叠"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-层叠"}},[t._v("#")]),t._v(" CSS 层叠")]),t._v(" "),s("p",[t._v("在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如："),s("code",[t._v("div p { font-size :14px }")]),t._v(" 会先寻找所有的 "),s("code",[t._v("p")]),t._v(" 标签然后判断它的父元素是否为 "),s("code",[t._v("div")]),t._v("。")]),t._v(" "),s("p",[t._v("所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。")]),t._v(" "),s("h4",{attrs:{id:"css-级联"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-级联"}},[t._v("#")]),t._v(" CSS 级联")]),t._v(" "),s("p",[t._v("浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做"),s("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity",target:"_blank",rel:"noopener noreferrer"}},[t._v("css specificity"),s("OutboundLink")],1),t._v("的公式，这个公式会通过：")]),t._v(" "),s("ul",[s("li",[t._v("!important，特性值最大，优先性最高")]),t._v(" "),s("li",[t._v("特性值大的优先")]),t._v(" "),s("li",[t._v("特性值如果一样，那么就近原则")])]),t._v(" "),s("p",[t._v("对于第二点特性值的具体计算如下：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("属性")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("特性值")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("行内样式表")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("1000")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("id选择器")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("100")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("类选择器、属性选择器、伪类选择器")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("10")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("标签选择器")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("层级选择器（空格、>、+、~、*）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("0")])])])]),t._v(" "),s("p",[t._v("然后相加得出一个权重值，取最高的那个。")]),t._v(" "),s("h3",{attrs:{id:"_2-2-解析流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-解析流程"}},[t._v("#")]),t._v(" 2.2 解析流程")]),t._v(" "),s("p",[s("img",{attrs:{src:a(441),alt:"cssom解析流程"}}),t._v(" "),t._v("\n构建CSSOM的过程与构建DOM的过程非常相似，当"),s("code",[t._v("css解析器")]),t._v("接收到网络线程返回的"),s("code",[t._v("text/css")]),t._v("类型字节流之后，然后解码成CSS文本字符串，再进行解析、标准化转换、符号化（Tokenization），然后构建Nodes节点最后生成CSSOM。")]),t._v(" "),s("p",[t._v("在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。")]),t._v(" "),s("h4",{attrs:{id:"格式转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#格式转换"}},[t._v("#")]),t._v(" 格式转换")]),t._v(" "),s("p",[t._v("解码之后，CSS解析器 会根据"),s("a",{attrs:{href:"https://drafts.csswg.org/css-syntax-3/",target:"_blank",rel:"noopener noreferrer"}},[t._v("语法规范"),s("OutboundLink")],1),t._v("，对CSS文本字符串（link引用的css文件、style标签内的CSS、元素style属性内嵌的CSS）执行一个解析操作，将CSS文本字符串转换成浏览器可以理解的结构 — "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Style_sheet_(web_development)",target:"_blank",rel:"noopener noreferrer"}},[t._v("样式表-Style Sheets"),s("OutboundLink")],1),t._v("。")]),t._v(" "),s("h4",{attrs:{id:"标准化-normalization-属性值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标准化-normalization-属性值"}},[t._v("#")]),t._v(" 标准化（Normalization）属性值")]),t._v(" "),s("p",[s("img",{attrs:{src:a(442),alt:"css标准化"}}),t._v(" "),t._v("\n转换样式表中的属性值（如颜色、尺寸等），使其标准化（Normalization）。")]),t._v(" "),s("h4",{attrs:{id:"符号化-tokenization-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号化-tokenization-2"}},[t._v("#")]),t._v(" 符号化（Tokenization）")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("符号化是词法分析的过程，将 样式表 解析成符号（Token）")])]),t._v(" 。在词法分析阶段，CSS 代码被分解为一系列的令牌（Tokens），每个令牌代表 CSS 代码的一个部分，如"),s("code",[t._v("选择器")]),t._v("、"),s("code",[t._v("属性名")]),t._v("、"),s("code",[t._v("属性值")]),t._v("、"),s("code",[t._v("分号")]),t._v("、"),s("code",[t._v("大括号")]),t._v("等。")]),t._v(" "),s("h4",{attrs:{id:"生成nodes并构建cssom-tree-construction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成nodes并构建cssom-tree-construction"}},[t._v("#")]),t._v(" 生成Nodes并构建CSSOM（tree construction）")]),t._v(" "),s("blockquote",[s("p",[t._v("语法分析（Syntax Analysis）：是指应用语言语法规则分析文档结构，进而构建解析树。在语法分析阶段，词法分析生成的令牌/标记被组织成"),s("code",[t._v("语法树（Parse Tree）")]),t._v("或"),s("code",[t._v("抽象语法树（AST）")]),t._v("。这个树状结构表示了 CSS 代码的层次结构和语法关系。")])]),t._v(" "),s("p",[s("img",{attrs:{src:a(443),alt:"CSSOM"}}),t._v(" "),t._v("\n这个阶段会经历 "),s("code",[t._v("语法分析")]),t._v("，根据"),s("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity",target:"_blank",rel:"noopener noreferrer"}},[t._v("css specificity"),s("OutboundLink")],1),t._v("计算"),s("code",[t._v("选择器特异性")]),t._v("，根据"),s("code",[t._v("CSS继承和层叠")]),t._v("规则等计算标签节点样式，最后生成CSSOM。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-为什么需要cssom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-为什么需要cssom"}},[t._v("#")]),t._v(" 2.3 为什么需要CSSOM")]),t._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://www.w3.org/TR/cssom-1/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSSOM"),s("OutboundLink")],1),t._v(" 是由 CSS 文本解析得到的渲染引擎能够识别的结构，类似 HTML 和 DOM 的关系，CSSOM 树描述的是选择器之间的层级关系，可以为 JavaScript 提供操作样式表的能力，还能为布局树的合成提供基础样式信息。体现在 DOM 中即 "),s("code",[t._v("document.styleSheets")]),t._v("。")])]),t._v(" "),s("p",[t._v("CSSOM是依赖DOM树的，既然已经有了DOM树结构来表示HTML文档，那为什么不把CSS顺便放在DOM上，以便我们直接从Element上获取所有样式信息呢？")]),t._v(" "),s("p",[t._v("因为如果把CSS信息一起建模在DOM结构上，就会违背"),s("code",[t._v("单一职责原则")]),t._v("。因为正如在网页中HTML承担了语义职能，CSS承担了表现职能一样，在计算机中DOM承担了语义职能，而CSSOM承担了表现职能。")]),t._v(" "),s("h2",{attrs:{id:"_3-生成渲染树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-生成渲染树"}},[t._v("#")]),t._v(" 3. 生成渲染树")]),t._v(" "),s("p",[t._v("DOM树和CSS规则树全部准备好了以后，浏览器才会开始构建渲染树。其实这就是一个 DOM 树和 CSSOM 树合并的过程。")]),t._v(" "),s("p",[t._v("在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式（CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要尽量小，CSS尽量使用id和class，不要过度层叠）。")]),t._v(" "),s("h3",{attrs:{id:"_3-1-工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-工作流程"}},[t._v("#")]),t._v(" 3.1 工作流程")]),t._v(" "),s("p",[t._v("渲染树的重要特性是它仅捕获可见内容，构建渲染树浏览器需要做以下工作：")]),t._v(" "),s("ul",[s("li",[t._v("从 DOM 树的根节点开始遍历每个可见节点（应用了具有类似内容的伪类 "),s("code",[t._v('p::before{content:"Hi!"}')]),t._v(" 也会包含在渲染树中，即使它不在DOM中）；")]),t._v(" "),s("li",[t._v("有些节点不可见（"),s("code",[t._v("<html>")]),t._v("、"),s("code",[t._v("<script>")]),t._v("、"),s("code",[t._v("<link>")]),t._v("等），因为它们不会体现在渲染输出中，所以会被忽略；")]),t._v(" "),s("li",[t._v("某些节点被CSS隐藏（设置了"),s("code",[t._v("display: none")]),t._v("属性，"),s("code",[t._v("visibility: hidden")]),t._v("则不会），因此在渲染树中也会被忽略；")]),t._v(" "),s("li",[t._v("对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/03/22/BDOCTF1Qhn4tW5U.png",alt:"渲染树"}})]),s("figcaption",[t._v("Render 树上的每一个节点被称为："),s("code",[t._v("RenderObject")]),t._v("（Blink内核中叫 LayoutObject）")]),s("p"),t._v(" "),s("h3",{attrs:{id:"_3-2-延伸阅读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-延伸阅读"}},[t._v("#")]),t._v(" 3.2 延伸阅读")]),t._v(" "),s("h4",{attrs:{id:"cssom-会阻塞生成渲染树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cssom-会阻塞生成渲染树"}},[t._v("#")]),t._v(" CSSOM 会阻塞生成渲染树")]),t._v(" "),s("p",[s("img",{attrs:{src:a(444),alt:"css阻塞render"}}),t._v(" "),s("strong",[t._v("CSS 加载不会阻塞 DOM 树的解析，但会阻塞 渲染树 的生成（解析白屏）")]),t._v("，即阻塞页面的显示，因为需要等待构建 CSSOM 完成后再进行构建布局树。")]),t._v(" "),s("h4",{attrs:{id:"css-会阻塞javascript执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-会阻塞javascript执行"}},[t._v("#")]),t._v(" CSS 会阻塞JavaScript执行")]),t._v(" "),s("p",[t._v("我们都知道，在解析html构建DOM的过程中，JS的加载、解析与执行，会阻塞DOM的构建过程。因为 JavaScript 可能会修改当前状态下的 DOM，如果不阻塞，那么这边在构建DOM，那边JavaScript在改DOM，如何保障最终得到的DOM是否正确？因此，为了防止渲染出现不可预期的结果，所以需要阻塞 DOM 解析。\n")]),t._v(" "),s("p",[s("img",{attrs:{src:a(445),alt:"css阻塞js"}})]),s("figcaption",[t._v("JavaScript 会阻塞 DOM树 构建，而 CSS 又会阻塞 JavaScript 的执行，因此 CSS 有时也会阻塞 DOM树 构建")]),s("p"),t._v(" "),s("p",[t._v("但是，"),s("em",[s("strong",[t._v("JavaScript对渲染过程的影响不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建")])]),t._v("。因为 JavaScript 具有修改 CSSOM 的能力，所以在js脚本执行前，如果发现页面中包含 CSS样式 (外部文件引用或内置 style 标签) 还需要等待CSSOM的生成。")]),t._v(" "),s("h2",{attrs:{id:"_4-布局渲染树-生成layout-tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-布局渲染树-生成layout-tree"}},[t._v("#")]),t._v(" 4. 布局渲染树，生成Layout Tree")]),t._v(" "),s("blockquote",[s("p",[t._v("重排/回流（reflow）：某个元素的尺寸、位置、内容、字体大小等发生了变化，则需重新计算渲染树，重新渲染。reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。")])]),t._v(" "),s("p",[t._v("“布局”就是计算渲染树中所有节点的几何属性，比如：位置、大小、边框、形状等。")]),t._v(" "),s("h3",{attrs:{id:"_4-1-工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-工作流程"}},[t._v("#")]),t._v(" 4.1 工作流程")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/03/22/PXBvjVhRSEL1kre.png",alt:"Layout渲染树"}})]),s("figcaption",[t._v("主线程使用计算样式遍历 DOM 树并生成布局树")]),s("p"),t._v(" "),s("p",[t._v("确定页面的布局是一项耗时的任务。即使是最简单的页面布局，例如：从上到下的流式布局，也必须考虑字体有多大以及在哪里换行，因为这些会影响段落的大小和形状，这会影响下一段的位置；CSS 可以使元素向一侧浮动、屏蔽溢出项以及改变书写方向。")]),t._v(" "),s("p",[t._v("可以想象，这个布局阶段的任务是艰巨的。在 Chrome 中，有一整个工程师团队负责布局模块。如果你想具体了解其中的工作细节，可以点击查看"),s("a",{attrs:{href:"https://www.youtube.com/watch?v=Y5Xa4H2wtVA",target:"_blank",rel:"noopener noreferrer"}},[t._v("few talks from BlinkOn Conference"),s("OutboundLink")],1),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_4-2-延伸阅读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-延伸阅读"}},[t._v("#")]),t._v(" 4.2 延伸阅读")]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.nowamagic.net/academy/detail/48110609",target:"_blank",rel:"noopener noreferrer"}},[t._v("Dirty bit系统"),s("OutboundLink")],1),t._v("：为了不因为每个小变化都全部重新布局，浏览器使用一个dirty bit系统，一个渲染对象发生了变化或是被添加了，就标记它及它的children为dirty——需要layout。存在两个标识——dirty及children are dirty，children are dirty说明即使这个渲染对象可能没问题，但它至少有一个child需要layout。")]),t._v(" "),s("h2",{attrs:{id:"_5-分层布局树-生成layer-tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-分层布局树-生成layer-tree"}},[t._v("#")]),t._v(" 5. 分层布局树，生成Layer Tree")]),t._v(" "),s("blockquote",[s("p",[s("code",[t._v("渲染层（RenderLayers）")]),t._v(" 的存在是为了使页面元素以正确的顺序组合，以正确显示重叠内容、半透明元素等。可以在DevTools的"),s("code",[t._v("Performance —> Layers")]),t._v("面板，查看网站具体是如何划分层的。")])]),t._v(" "),s("p",[s("img",{attrs:{src:a(446),alt:"分层布局树"}}),t._v(" "),t._v("\n布局渲染树后，渲染引擎并不是直接使用渲染树进行绘制，渲染引擎还要遍历布局树，为特定的节点生成专用的图层（RenderLayer），并生成对应的图层树（Layer Tree）。")]),t._v(" "),s("h3",{attrs:{id:"_5-1-生成规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-生成规则"}},[t._v("#")]),t._v(" 5.1 生成规则")]),t._v(" "),s("p",[t._v("布局树的节点默认从属于父节点图层，满足以下两点中任何一点的元素可被单独提升为一个图层：")]),t._v(" "),s("h4",{attrs:{id:"拥有层叠上下文属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拥有层叠上下文属性"}},[t._v("#")]),t._v(" 拥有层叠上下文属性")]),t._v(" "),s("p",[s("img",{attrs:{src:a(447),alt:"层叠上下文属性"}}),t._v("\n明确"),s("code",[t._v("定位（position）")]),t._v("、"),s("code",[t._v("透明（opacity）")]),t._v("、"),s("code",[t._v("CSS 滤镜（filter）")]),t._v("、"),s("code",[t._v("transform 动画")]),t._v("等拥有"),s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context",target:"_blank",rel:"noopener noreferrer"}},[t._v("层叠上下文"),s("OutboundLink")],1),t._v("属性的元素。")]),t._v(" "),s("h4",{attrs:{id:"需要剪裁-clip-的内容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#需要剪裁-clip-的内容"}},[t._v("#")]),t._v(" 需要剪裁(clip)的内容")]),t._v(" "),s("p",[s("img",{attrs:{src:a(448),alt:"剪裁属性"}})]),t._v(" "),s("p",[t._v("当内容展示不下被隐藏或出现滚动条时，内容区域 会单独创建一个图层。")]),t._v(" "),s("h3",{attrs:{id:"_5-2-延伸阅读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-延伸阅读"}},[t._v("#")]),t._v(" 5.2 延伸阅读")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/blog/broswer/compositor-layer-manage.html"}},[t._v("合成层优化")]),t._v("：在Chrome的渲染机制中，图层分成两种，除了渲染层，还有"),s("code",[t._v("合成层（Compositing Layers）")]),t._v("。渲染层可以提升成合成层，提升成合成层后，便不会影响到其他元素的绘制。")],1),t._v(" "),s("p",[t._v("具体 合成层提升规则、工作原理，优化以及调试手段等，可以点击"),s("RouterLink",{attrs:{to:"/blog/broswer/compositor-layer-manage.html"}},[t._v("查看")]),t._v("。")],1),t._v(" "),s("h2",{attrs:{id:"_6-绘制与合成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-绘制与合成"}},[t._v("#")]),t._v(" 6. 绘制与合成")]),t._v(" "),s("p",[t._v("绘制（paint）和分层几乎是同时发生的，也就是说主线程遍历布局树生成"),s("code",[t._v("Layer Tree")]),t._v("的同时，也会生成"),s("code",[t._v("绘制记录")]),t._v("。所以有的文章或书籍将分层放在绘制之后，虽然不完全准确（因为绘制是一个多步骤的过程，下面会详细说明），但也可以理解。")]),t._v(" "),s("h3",{attrs:{id:"_6-1-基础概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-基础概念"}},[t._v("#")]),t._v(" 6.1 基础概念")]),t._v(" "),s("h4",{attrs:{id:"图块-tile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图块-tile"}},[t._v("#")]),t._v(" 图块（Tile）")]),t._v(" "),s("p",[s("img",{attrs:{src:a(449),alt:"图块"}})]),s("figcaption",[t._v("黄色框内区域为图块（没有经过绘制，里面包含每个元素的几何信息、样式属性以及绘制的顺序）")]),t._v(" "),s("p"),t._v(" "),s("p",[t._v("合成线程会将每个图层划分为若干个图块，图块大小通常为"),s("code",[t._v("256x256")]),t._v("或"),s("code",[t._v("512x512")]),t._v("。")]),t._v(" "),s("h4",{attrs:{id:"位图-bitmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#位图-bitmap"}},[t._v("#")]),t._v(" 位图（BitMap）")]),t._v(" "),s("p",[s("img",{attrs:{src:a(450),alt:"位图"}})]),t._v(" "),s("p",[t._v("位图 是一种图像存储方式，将图像划分为一个"),s("code",[t._v("像素")]),t._v("（图像的最小单元）矩阵，每个像素通常由颜色信息（如红、绿、蓝）和可能的其他信息（如透明度或深度值）组成。")]),t._v(" "),s("p",[t._v("想像一下如果要绘制出一张图片，你应该怎么做，显然首先是把这个图片表示为一种计算机能理解的数据结构："),s("red",[t._v("用一个二维数组，数组的每个元素记录这个图片中的每一个像素的具体颜色。")]),t._v("所以浏览器可以用位图来记录他想在某个区域绘制的内容，绘制的过程也就是往数组中具体的下标里填写像素而已。")],1),t._v(" "),s("p",[t._v("所有的位图（包括图片、文本、栅格化的内容），最终都要由内存发送到"),s("code",[t._v("显存")]),t._v("，绑定为 GPU Texture（GPU纹理/贴图）。不论是提交到"),s("code",[t._v("显存")]),t._v("的过程，还是 "),s("code",[t._v("GPU调整")]),t._v("和"),s("code",[t._v("渲染Texture")]),t._v("的过程，都要消耗不少 GPU 资源。")]),t._v(" "),s("h4",{attrs:{id:"显存-gpu-video-ram"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#显存-gpu-video-ram"}},[t._v("#")]),t._v(" 显存（GPU Video RAM）")]),t._v(" "),s("p",[t._v("通常称为"),s("code",[t._v("视频内存")]),t._v("或"),s("code",[t._v("显存")]),t._v("，是一块专门的内存，用于存储图形和视频数据，以供图形处理单元（GPU）进行快速访问和处理。")]),t._v(" "),s("p",[t._v("显存用于存储屏幕上的 "),s("code",[t._v("像素数据")]),t._v("、"),s("code",[t._v("纹理")]),t._v("、"),s("code",[t._v("渲染缓冲区")]),t._v("、"),s("code",[t._v("帧缓冲区")]),t._v("和其他与图形相关的数据。这些数据需要快速访问，以便在屏幕上渲染图像。")]),t._v(" "),s("h4",{attrs:{id:"纹理-texture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#纹理-texture"}},[t._v("#")]),t._v(" 纹理（Texture）")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("纹理其实就是存储在GPU中的位图")])]),t._v("。GPU纹理存储，需要有固定格式，如"),s("code",[t._v("R5G6B5")]),t._v("、"),s("code",[t._v("A4R4G4B4")]),t._v("等像素格式，便于兼容与处理。")]),t._v(" "),s("p",[t._v("另外 GPU 对纹理大小有限制，比如长/宽必须是"),s("code",[t._v("2的幂次方")]),t._v("，最大不能超过2048或者4096等。")]),t._v(" "),s("h4",{attrs:{id:"绘制记录-paint-records"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#绘制记录-paint-records"}},[t._v("#")]),t._v(" 绘制记录（Paint Records）")]),t._v(" "),s("p",[t._v("通常也被称为"),s("code",[t._v("绘制调用记录（the recording of draw calls）")]),t._v("，或者"),s("code",[t._v("绘制指令列表")]),t._v("，里面包含了，用来记录绘制顺序（例如先绘制背景，然后是文字，然后是形状..）。")]),t._v(" "),s("p",[t._v("绘制记录序列化后会被存入到"),s("code",[t._v("SkPicture")]),t._v("中。")]),t._v(" "),s("h4",{attrs:{id:"skpicture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#skpicture"}},[t._v("#")]),t._v(" SkPicture")]),t._v(" "),s("p",[t._v("合成线程上的 SkPicture 是一个可序列化的数据结构，可以捕获然后重播命令。"),s("code",[t._v("绘制（paint）")]),t._v("第1步中所生成的"),s("code",[t._v("绘制记录")]),t._v("会序列化进入其中，然后在光栅化时 replay 绘制调用命令。")]),t._v(" "),s("p",[s("code",[t._v("SkPicture记录")]),t._v("可以通过以下两种方式之一转换为 GPU 上的位图：")]),t._v(" "),s("ul",[s("li",[t._v("由 Skia 的软件光栅化绘制为位图并作为纹理上传到 GPU；")]),t._v(" "),s("li",[t._v("由 Skia 的 OpenGL 后端 (Ganesh) 直接绘制为 GPU 上的纹理。")])]),t._v(" "),s("h4",{attrs:{id:"光栅化-rasterize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#光栅化-rasterize"}},[t._v("#")]),t._v(" 光栅化（Rasterize）")]),t._v(" "),s("p",[s("img",{attrs:{src:a(451),alt:"光栅化"}})]),t._v(" "),s("p",[s("em",[s("strong",[t._v("回放"),s("code",[t._v("绘制记录")]),t._v("，执行绘制命令，将图层的"),s("code",[t._v("图块")]),t._v("转化成"),s("code",[t._v("位图")]),t._v("的过程叫做光栅化")])]),t._v("。视口附近的图块会优先生成位图，合成线程可以决定栅格线程光栅化图块的优先级，这样可以保证用户能看到的部分可以先被光栅化。一个层也会包含多种块以支持类似缩放这样的功能。")]),t._v(" "),s("p",[t._v("在纹理里填充像素不是那么简单的自己去遍历位图里的每个元素然后填写这个像素的颜色的。"),s("strong",[t._v("光栅化的本质是坐标变换、几何离散化，然后再填充")]),t._v("。")]),t._v(" "),s("p",[t._v("光栅化包括"),s("code",[t._v("软件光栅化")]),t._v("和"),s("code",[t._v("硬件光栅化")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("软件光栅化（Software Rasterization）")])]),t._v(" "),s("p",[t._v("基于CPU、使用"),s("code",[t._v("Skia库")]),t._v("，首先在CPU中绘制像素进位图，然后再作为纹理上传至"),s("code",[t._v("GPU显存")]),t._v("。")]),t._v(" "),s("p",[t._v("软件光栅化可能非常昂贵，因此这种光栅化不会发生在合成线程中（它可能会阻止为活动树绘制新帧），而是发生在"),s("code",[t._v("栅格线程")]),t._v("中。可以使用多个栅格线程来加速软件光栅化。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("硬件光栅化（Hardware Rasterization）")])]),t._v(" "),s("p",[t._v("也就是我们常说的"),s("code",[t._v("GPU Raster")]),t._v("。基于GPU、借助"),s("code",[t._v("Skia’s OpenGL backend (Ganesh)")]),t._v("直接在GPU中进行光栅化，绘制填充像素，生成纹理。")]),t._v(" "),s("p",[t._v("当合成线程决定光栅化任何图块时，将 图块 捆绑在一起发送给GPU（避免GPU上的图块光栅化产生过高的开销），然后调用"),s("code",[t._v("SkPicture")]),t._v("回放"),s("code",[t._v("绘制记录")]),t._v("，并经由"),s("code",[t._v("Ganesh")]),t._v("处理转换生成 "),s("code",[t._v("GL命令流")]),t._v("，然后将 GL命令 通过"),s("code",[t._v("命令缓冲区")]),t._v("传递给 "),s("code",[t._v("GPU进程")]),t._v("，然后GPU线程借助"),s("code",[t._v("Ganesh")]),t._v("光栅化图块。")])])]),t._v(" "),s("p",[t._v("使用 硬件光栅化 的好处在于：以往 软件光栅化 的方式，受限于 CPU 和 GPU 之前的上传带宽，把 位图 从 RAM 里上传到 GPU 的 VRAM（显存） 里的过程是有不可忽视的性能开销的。若 光栅化 的区域较大，那么使用 软件光栅化 很可能在这里出现卡顿。")]),t._v(" "),s("p",[t._v("现在基本最新版的几大浏览器都是"),s("code",[t._v("硬件光栅化")]),t._v("了，但是对于一些移动端基本还是"),s("code",[t._v("软件光栅化")]),t._v("较多。打开chrome浏览器输入"),s("code",[t._v("chrome://gpu/")]),t._v(" 可以查看GPU加速情况。")]),t._v(" "),s("h4",{attrs:{id:"绘制-paint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#绘制-paint"}},[t._v("#")]),t._v(" 绘制（paint）")]),t._v(" "),s("p",[t._v("绘制通常表示在图层表面上进行的一系列操作。")]),t._v(" "),s("p",[t._v("有时您可能会听到与绘制一起使用的术语“光栅化”。这是因为绘制实际上是两个任务：")]),t._v(" "),s("ul",[s("li",[t._v("1）生成"),s("code",[t._v("绘制记录")]),t._v("（这个过程和遍历布局树生成"),s("code",[t._v("layer Tree")]),t._v("是同时发生的）；")]),t._v(" "),s("li",[t._v("2）光栅化（回放"),s("code",[t._v("绘制记录")]),t._v("，执行绘制命令，填充像素：包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果）。")])]),t._v(" "),s("h4",{attrs:{id:"draw-quads"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#draw-quads"}},[t._v("#")]),t._v(" Draw Quads")]),t._v(" "),s("p",[t._v("是一组包含位图在"),s("code",[t._v("GPU显存")]),t._v("中的具体存储位置、以及将这些位图drawing在页面哪个位置的数据信息，用于描述如何使用位图合成页面。")]),t._v(" "),s("h4",{attrs:{id:"合成帧-compositor-frame"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合成帧-compositor-frame"}},[t._v("#")]),t._v(" 合成帧（Compositor Frame）")]),t._v(" "),s("p",[t._v("存储了页面某一帧中关于"),s("code",[t._v("Draw quads")]),t._v("的集合。合成帧用于将所有纹理合并成一个大的图像或帧。")]),t._v(" "),s("h4",{attrs:{id:"合成-composite"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合成-composite"}},[t._v("#")]),t._v(" 合成（composite）")]),t._v(" "),s("p",[t._v("合成是一种将页面的各个部分分成图层、分别光栅化并在合成线程中创建合成帧，最终合成为页面的技术。如果发生滚动，由于图层已经光栅化，它所要做的就是合成一个新帧。动画则可以通过移动层来实现。")]),t._v(" "),s("h4",{attrs:{id:"帧缓冲区-frame-buffer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#帧缓冲区-frame-buffer"}},[t._v("#")]),t._v(" 帧缓冲区（Frame Buffer）")]),t._v(" "),s("p",[t._v("帧缓冲区是计算机图形学中的一个重要概念，通常指的是用于存储图像或帧的内存区域。它在图形渲染和显示过程中扮演关键角色，允许计算机生成和显示图像。")]),t._v(" "),s("p",[t._v("在渲染过程中，计算机生成图像的每一帧（包括三维渲染、图像处理、动画等应用），通常首先被放入到帧缓冲区中。一旦图像被绘制到帧缓冲区中，它可以被传送到显示设备（通常是计算机显示器）上显示给用户。这个过程通常以连续的方式进行，以创建平滑的动画或视频。")]),t._v(" "),s("h4",{attrs:{id:"draw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#draw"}},[t._v("#")]),t._v(" draw")]),t._v(" "),s("p",[t._v("表示GPU最终把纹理显示到屏幕上的过程。")]),t._v(" "),s("h3",{attrs:{id:"_6-2-工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-工作流程"}},[t._v("#")]),t._v(" 6.2 工作流程")]),t._v(" "),s("p",[s("img",{attrs:{src:a(452),alt:"工作流程"}})]),t._v(" "),s("p",[t._v("具体工作流程如下：")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("主线程 遍历生成"),s("code",[t._v("layer Tree")]),t._v("的同时，会生成"),s("code",[t._v("绘制记录")]),t._v("，然后主线程会将各个图层和绘制记录commit到合成线程（其中绘制记录会序列化存入"),s("code",[t._v("SkPicture")]),t._v("）；\n"),s("img",{attrs:{src:a(453),alt:"Paint Records"}})])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("合成线程将每个图层分成若干个"),s("code",[t._v("图块（tile）")]),t._v("，然后发送给 "),s("code",[t._v("栅格化线程池")]),t._v("， 多个"),s("code",[t._v("栅格线程")]),t._v("并行调用"),s("code",[t._v("SkPicture")]),t._v("回放绘制命令记录，分别"),s("code",[t._v("光栅化")]),t._v("图块，并将转换后的"),s("code",[t._v("位图")]),t._v("上传到"),s("code",[t._v("GPU")]),t._v("并作为纹理存储；\n"),s("img",{attrs:{src:a(454),alt:"Raster threads"}})])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("所有图块光栅化完成后，合成线程收集"),s("code",[t._v("Draw Quads")]),t._v("信息并创建"),s("code",[t._v("合成帧")]),t._v("，然后合成帧通过"),s("code",[t._v("IPC管道")]),t._v("被发送给浏览器进程；\n"),s("img",{attrs:{src:a(455),alt:"DrawQuad"}})])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[t._v("浏览器进程接收到"),s("code",[t._v("合成帧")]),t._v("之后，便将 合成帧 发送给 GPU，GPU根据 合成帧 进行合并渲染（对"),s("code",[t._v("显存")]),t._v("中所有纹理合并成一个最终的图像或帧）。这时如果浏览器UI有变化，或者插件的UI有变化时，另一个合成帧就会被创建出来。所以每当有交互发生时，合成线程就会创建更多的合成帧然后通过GPU将新的部分渲染出来；")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"5"}},[s("li",[t._v("GPU 渲染完成后将渲染结果放入"),s("code",[t._v("帧缓冲区")]),t._v("，视频控制器会按照 "),s("code",[t._v("VSync（垂直同步）")]),t._v(" 信号逐行读取帧缓冲区的数据（接收到Vsync信号，这一帧开始），经过可能的数模转换传递给显示器显示。")])])])]),t._v(" "),s("p",[t._v("以上步骤2、3、4是 "),s("strong",[t._v("软件光栅化")]),t._v(" 的完整流程。")]),t._v(" "),s("p",[t._v("而 "),s("strong",[t._v("硬件光栅化")]),t._v(" 时：")]),t._v(" "),s("ul",[s("li",[t._v("合成线程调用"),s("code",[t._v("SkPicture")]),t._v("回放"),s("code",[t._v("绘制记录")]),t._v("，并经由"),s("code",[t._v("Ganesh")]),t._v("处理转换生成 "),s("code",[t._v("GL命令流")]),t._v("，然后将 GL命令 通过 命令缓冲区 传递给 GPU Thread；")]),t._v(" "),s("li",[t._v("GPU Thread 读取 GL命令，借助 "),s("code",[t._v("Ganesh")]),t._v(" 直接在GPU中进行光栅化生成纹理，光栅化完毕后，GPU Thread 调用平台对应的"),s("code",[t._v("3D API")]),t._v("(windows下是D3D，其他平台都是GL)，进行纹理的合并。GPU合并渲染完成后，再进行步骤5。")])]),t._v(" "),s("p",[s("red",[t._v("在纹理的合并时，借助于3D API的相关合成参数，可以在合并前对纹理Transformations（也就是之前提到的位移、旋转、缩放、alpha通道改变等等操作），先变形再合并")]),t._v("。")],1),t._v(" "),s("h3",{attrs:{id:"_6-3-延伸阅读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-延伸阅读"}},[t._v("#")]),t._v(" 6.3 延伸阅读")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/blog/broswer/reflow-repaint-composite.html"}},[t._v("重排、重绘与合成")]),t._v("：而渲染流水线任意一帧的生成方式，有 "),s("code",[t._v("重排")]),t._v("、"),s("code",[t._v("重绘")]),t._v("和"),s("code",[t._v("合成")]),t._v("三种方式，按照效率推荐合成方式优先，在不能满足需求时使用重绘甚至重排的方式。这篇文章重点放在讲解浏览器重排、重绘与合成的概念、渲染区别、优化手段等。")],1),t._v(" "),s("h2",{attrs:{id:"_7-接收到用户输入浏览器怎么处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-接收到用户输入浏览器怎么处理"}},[t._v("#")]),t._v(" 7. 接收到用户输入浏览器怎么处理？")]),t._v(" "),s("p",[t._v("从浏览器的角度来看，输入意味着用户的任何手势。文本框中键入/单击鼠标是输入，鼠标滚轮滚动是输入，触摸/鼠标悬停也是输入事件。")]),t._v(" "),s("h3",{attrs:{id:"_7-1-工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-工作流程"}},[t._v("#")]),t._v(" 7.1 工作流程")]),t._v(" "),s("h4",{attrs:{id:"发送事件类型及坐标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发送事件类型及坐标"}},[t._v("#")]),t._v(" 发送事件类型及坐标")]),t._v(" "),s("p",[s("img",{attrs:{src:a(456),alt:"输入事件交互"}}),t._v(" "),t._v("\n当用户手势（例如触摸屏幕）发生时，"),s("code",[t._v("浏览器进程")]),t._v("是第一个接收该手势的进程。然而，浏览器主进程只知道手势发生的位置，因为选项卡内的内容是由渲染进程处理的。因此，浏览器进程需要将"),s("code",[t._v("事件类型（如click）及其坐标")]),t._v("发送到渲染进程。渲染进程通过查找"),s("code",[t._v("事件目标（event target）")]),t._v("并运行附加的"),s("code",[t._v("事件侦听器（event listener）")]),t._v("来适当地处理事件。")]),t._v(" "),s("h4",{attrs:{id:"检查非快速滚动区域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#检查非快速滚动区域"}},[t._v("#")]),t._v(" 检查非快速滚动区域")]),t._v(" "),s("p",[t._v("由于运行 JavaScript 是主线程的工作，因此当合成页面时，合成线程会将附加了事件处理程序的页面区域标记为"),s("code",[t._v("非快速滚动区域（non-fast scrollable region）")]),t._v("。\n"),s("img",{attrs:{src:a(457),alt:"非快速滚动区域"}}),t._v(" "),s("em",[s("strong",[t._v("合成线程检查输入事件的坐标是否为 非快速滚动区域")])]),t._v("。如果事件发生在该区域，合成线程可以确保将输入事件发送到主线程。如果输入事件来自该区域之外，则合成线程将继续合成新帧，而无需等待主线程。")]),t._v(" "),s("h4",{attrs:{id:"查找事件的目标对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查找事件的目标对象"}},[t._v("#")]),t._v(" 查找事件的目标对象")]),t._v(" "),s("p",[s("img",{attrs:{src:a(458),alt:"绘制记录"}})]),t._v(" "),s("p",[t._v("当合成线程将输入事件发送到主线程时，首先要运行的是"),s("code",[t._v("命中测试（hit test）")]),t._v("来查找"),s("code",[t._v("事件目标")]),t._v("。命中测试 使用渲染过程中生成的"),s("code",[t._v("绘制记录")]),t._v("数据来找出输入事件发生的"),s("code",[t._v("x, y坐标点")]),t._v("上对应的是哪个对象元素。然后触发目标对象绑定事件的JavaScript执行。")]),t._v(" "),s("h3",{attrs:{id:"_7-2-慎用body的事件委托"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-慎用body的事件委托"}},[t._v("#")]),t._v(" 7.2 慎用body的事件委托")]),t._v(" "),s("p",[t._v("Web 开发中有一种常见的事件处理模式是事件委托（event delegation）。由于事件的冒泡，您可以给顶层元素（如body）绑定一个事件监听函数来作为其所有子元素的事件委托者，然后根据事件目标进行任务处理。您可能已经看到或编写过如下代码。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'touchstart'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" area"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// todo")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这种为所有元素绑定一个事件监听函数的写法看上去代码很简洁。可是，如果从浏览器的角度去审视该代码，你会发现整个页面都标记成了一个非快速滚动区域。这就意味着即使你页面的某些区域压根不在乎是不是有用户输入，当用户输入事件发生时，合成线程每次都会与主线程进行通信，并且会等待主线程处理完js任务才干活。因此这种情况下，合成线程就丧失了"),s("code",[t._v("平滑滚动能力（smooth scrolling ability）")]),t._v("。\n"),s("img",{attrs:{src:a(459),alt:"无法平滑滚动"}}),t._v(" "),t._v("\n为了减轻这种情况的发生，您可以在事件侦听器中添加"),s("code",[t._v("passive: true")]),t._v("选项。这个选项会告诉浏览器你仍希望在主线程中监听事件，但合成线程也可以继续合成新帧。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'touchstart'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" area"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// todo")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("passive")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"_7-3-最小化向主线程调度事件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-最小化向主线程调度事件"}},[t._v("#")]),t._v(" 7.3 最小化向主线程调度事件")]),t._v(" "),s("p",[t._v("显示器的刷新频率通常是 60/s，我们可以通过让JS代码的执行频率和屏幕刷新频率保持一致来实现页面的"),s("code",[t._v("平滑动画（smooth animation）")]),t._v("效果。对于用户输入来说，触摸屏一般每秒传送触摸事件 60-120 次，而鼠标则会每秒传送事件100次，因此输入事件的触发频率其实远远高于我们屏幕的刷新频率。")]),t._v(" "),s("p",[t._v("如果像"),s("code",[t._v("touchmove")]),t._v("这样的连续事件每秒发送到主线程 120 次，那么与屏幕刷新速度相比，它可能会触发过量的命中测试和 JavaScript 执行。\n"),s("img",{attrs:{src:a(460),alt:"事件频繁导致页面卡顿"}}),t._v(" "),t._v("\n为了最大限度地减少对主线程的过多调用，Chrome 会合并"),s("code",[t._v("连续事件")]),t._v("（如wheel、mousewheel、mousemove、pointermove、touchmove等），并将调度延迟到下一个"),s("code",[t._v("requestAnimationFrame")]),t._v("之前。\n"),s("img",{attrs:{src:a(461),alt:"事件合并延迟"}}),t._v(" "),t._v("\n任何"),s("code",[t._v("离散事件")]),t._v("（如keydown、keyup、mouseup、mousedown、touchstart、touchend、click等相对不怎么频繁触发的事件）都会立即调度。")]),t._v(" "),s("h2",{attrs:{id:"_8-参考文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-参考文档"}},[t._v("#")]),t._v(" 8. 参考文档")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developer.chrome.com/blog/inside-browser-part3/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Inside look at modern web browser (part 3)"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developer.chrome.com/blog/inside-browser-part4/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Inside look at modern web browser (part 4)"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://web.dev/howbrowserswork/",target:"_blank",rel:"noopener noreferrer"}},[t._v("How browsers work"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://book.douban.com/subject/25910556/",target:"_blank",rel:"noopener noreferrer"}},[t._v("WebKit技术内幕"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/",target:"_blank",rel:"noopener noreferrer"}},[t._v("GPU Accelerated Compositing in Chrome"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);