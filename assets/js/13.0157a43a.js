(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{510:function(e,t,v){e.exports=v.p+"assets/img/webview-load.a6861d46.png"},511:function(e,t,v){e.exports=v.p+"assets/img/offline-stage.3252e508.png"},512:function(e,t,v){e.exports=v.p+"assets/img/offline-process.c4c732eb.png"},513:function(e,t,v){e.exports=v.p+"assets/img/offline-hit.ba1cc0c8.png"},591:function(e,t,v){"use strict";v.r(t);var a=v(65),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"聊聊web离线缓存方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聊聊web离线缓存方案"}},[e._v("#")]),e._v(" 聊聊Web离线缓存方案")]),e._v(" "),a("p",[e._v("我们都清楚，在电商化背景下，用户体验是我们业务提升的重要考量因素。WEB作为公司业务的重要载体，其在移动端的表现会直接影响用户使用。")]),e._v(" "),a("p",[e._v("本文介绍的WEB离线缓存方案，能够让移动端WEB启动有接近APP原生页面的秒开体验。")]),e._v(" "),a("h2",{attrs:{id:"why不使用原生开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why不使用原生开发"}},[e._v("#")]),e._v(" Why不使用原生开发？")]),e._v(" "),a("ul",[a("li",[e._v("产品线众多（20+APP）")]),e._v(" "),a("li",[e._v("业务迭代速度快")]),e._v(" "),a("li",[e._v("H5业务占比重")])]),e._v(" "),a("h2",{attrs:{id:"app-webview中url从访问到展示发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#app-webview中url从访问到展示发生了什么"}},[e._v("#")]),e._v(" App WebView中Url从访问到展示发生了什么？")]),e._v(" "),a("p",[a("img",{attrs:{src:v(510),alt:"webview加载页面"}}),e._v("\n由上图我们可以知道，APP打开webview加载SPA页面的过程中，在webview的初始化和html页面解析渲染完成之前，页面是白屏的。")]),e._v(" "),a("p",[e._v("其实我们移动端的浏览器也是一个APP，只不过在浏览器中加载h5页面的流程少了webview的初始化。详细步骤可以查看"),a("RouterLink",{attrs:{to:"/blog/broswer/website-navigation.html"}},[e._v("从浏览器输入网址到页面加载，中间发生了什么？")])],1),e._v(" "),a("h2",{attrs:{id:"离线缓存方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#离线缓存方案"}},[e._v("#")]),e._v(" 离线缓存方案")]),e._v(" "),a("p",[e._v("离线缓存方案主要通过"),a("red",[e._v("离线预下载")]),e._v("（预先下载好 H5 页面所需要的资源文件）和 "),a("red",[e._v("请求拦截技术")]),e._v("（打开有离线资源的 H5 页面的时候可以通过拦截 WebView 的网络请求，将本地对应的Html、Css、Js 以及预加载的接口数据返回给Webview），减少网络因素对加载资源的影响，加快 Webview 对Web项目的加载速度。")],1),e._v(" "),a("h3",{attrs:{id:"性能优化原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化原理"}},[e._v("#")]),e._v(" 性能优化原理")]),e._v(" "),a("p",[a("img",{attrs:{src:v(511),alt:"webview加载页面"}}),e._v("\n当我们打开webview访问一个离线化页面时，app拦截我们发出的所有静态资源（Html、CSS、JS）网络请求，将本地离线预下载的资源文件返回给webview。通过这种方式，优化静态资源的加载耗时，从而优化 H5 页面的首屏展示时间。")]),e._v(" "),a("p",[e._v("另外，假如我们的项目配置了 "),a("code",[e._v("接口数据预加载")]),e._v("，app则会在webview初始化之后（发起静态资源请求的同时），解析页面的离线数据配置（里面包含了一个关于页面地址和接口url、请求方法、参数校验的映射），然后发起请求获取接口的返回数据。等到webview解析执行js代码阶段，发起当前接口请求时，app拦截接口请求并返回预加载的接口数据。通过这种方式，优化接口网络请求，从而优化数据加载耗时。")]),e._v(" "),a("h3",{attrs:{id:"离线包机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#离线包机制"}},[e._v("#")]),e._v(" 离线包机制")]),e._v(" "),a("p",[a("img",{attrs:{src:v(512),alt:"离线包机制"}})]),e._v(" "),a("ol",[a("li",[e._v("在 Luna管理平台 对 App 和 Web项目 进行注册和创建配置；")]),e._v(" "),a("li",[e._v("前端项目接入离线化webpack/vite插件，配置基本参数（比如projectGroup、projectName、domain、cdnPath、outPath、preload、pageWhiteList等）；")]),e._v(" "),a("li",[e._v("前端项目CI过程中，离线化插件生成离线化zip包，调用离线化上传接口；")]),e._v(" "),a("li",[e._v("离线化上传接口将其推送到离线包OSS云存储地址，并向数据库写入一条离线包基本信息（projectName、createUser、time、zipUrl等），供离线包部署平台部署上线使用；")]),e._v(" "),a("li",[e._v("在离线包部署平台进行“部署”操作，后台服务会运行"),a("code",[e._v("bs-diff算法")]),e._v("，生成近5个版本对比的增量包，并将其和zip的全量包一起上传到"),a("strong",[e._v("离线包cdn平台")]),e._v("，然后把离线包相关信息写入离线化配置数据库；")]),e._v(" "),a("li",[e._v("APP启动/轮询时，将本地储存的所有离线包基本信息（name: version）作为参数 调用离线包服务接口，从数据库读取APP离线包信息，返回离线包配置；")]),e._v(" "),a("li",[e._v("APP获取到离线包配置信息后，\n"),a("ul",[a("li",[e._v("if：返回了增量包地址，下载到本地，先进行验签（校验文件的完整性以及有没有被篡改），通过的话再进行 patch操作（"),a("em",[a("strong",[e._v("bs-diff算法将增量包和本地的zip包进行patch修补")])]),e._v("），生成一个新的zip包")]),e._v(" "),a("li",[e._v("else：没有返回增量包url，再看有没有返回全量包url，有的话，下载全量包到本地，进行验签，通过的话，保留全量包并删除老的离线包；")])])]),e._v(" "),a("li",[e._v("然后APP打开webview加载离线页面，将本地下载的离线包静态资源返回给webview。")])]),e._v(" "),a("h3",{attrs:{id:"离线包命中方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#离线包命中方案"}},[e._v("#")]),e._v(" 离线包命中方案")]),e._v(" "),a("p",[a("img",{attrs:{src:v(513),alt:"离线包命中方案"}})]),e._v(" "),a("ol",[a("li",[e._v("APP启动/轮询时，请求离线化配置接口，获取到最新的离线信息配置后，下载离线包资源，并在本地缓存一个"),a("code",[e._v("map.json")]),e._v("文件（关于项目、离线包版本号、离线文件路径的汇总映射文件）。")]),e._v(" "),a("li",[e._v("app webview在初始化加载h5页面的时候，读取"),a("code",[e._v("map.json")]),e._v("判断该页面是否是离线页面。如果不是，走线上逻辑；")]),e._v(" "),a("li",[e._v("是的话，再判断本地有没有离线包。假如没有，下载离线包先走线上逻辑；")]),e._v(" "),a("li",[e._v("假如有，对比内存中离线包是否一致。不一致，加载离线包至内存，加载失败，走线上逻辑；")]),e._v(" "),a("li",[e._v("一致，加载离线静态资源文件，将数据返回给webview。")])]),e._v(" "),a("h2",{attrs:{id:"qa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#qa"}},[e._v("#")]),e._v(" QA")]),e._v(" "),a("h3",{attrs:{id:"如何进行强制更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何进行强制更新"}},[e._v("#")]),e._v(" 如何进行强制更新？")]),e._v(" "),a("p",[e._v("在离线包部署平台“部署”新的离线包时，打开“强制更新”开关，进行部署。客户端收到通知以后，会删掉老的离线包，下载最新的离线包。")]),e._v(" "),a("h3",{attrs:{id:"如何强制访问线上页面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何强制访问线上页面"}},[e._v("#")]),e._v(" 如何强制访问线上页面？")]),e._v(" "),a("p",[e._v("在离线化配置里关闭项目的离线化，客户端读取到最新的离线化配置后，就会删除本地的离线包，更新"),a("code",[e._v("map.json")]),e._v("。")]),e._v(" "),a("p",[e._v("另外，我们在跳转的url上拼接"),a("strong",[e._v("强制更新参数")]),e._v("，app拦截webview过程中，假如发现url上带有该参数，就不会进行任何处理返回。")]),e._v(" "),a("h3",{attrs:{id:"为什么更新离线包不用push"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么更新离线包不用push"}},[e._v("#")]),e._v(" 为什么更新离线包不用push？")]),e._v(" "),a("p",[e._v("目前我们app初始化之后会5分钟轮询一次离线化接口，然后更新最新离线包，而且服务端会定时同步离线化配置到内存，不需要读库，这种机制暂时还不存在瓶颈。")]),e._v(" "),a("p",[e._v("另外假如使用push的话，当我们发布一个新的离线包，然后app收到通知，马上请求离线化接口，这样可能同一时间存在几百上千万的并发请求，对服务器的压力很大，有可能就得使用上redis。")])])}),[],!1,null,null,null);t.default=s.exports}}]);